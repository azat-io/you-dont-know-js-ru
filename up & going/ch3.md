# Вы не знаете JS: Приступим!
# Глава 3: Введение в "Вы не знаете JS"

О чем вся эта серия? Проще говоря, она о том как взяться серьезно за задачу изучения *всех частей JavaScript*, а не только некоторого подмножества языка, которое кто-то называет "основными частями", и не только совсем минимального количества, необходимого вам, чтобы сделать свою работу.

Серьезные разработчики в других языках обычно планируют приложить усилия для изучения большей части или всего языка, на котором они в основном пишут, но разработчики на JS похоже стоят в стороне от всех в том смысле, что типично не изучают многого в языке. Это не так уж и хорошо и это не то, чему нам следует продолжать позволять быть нормой.

Серия *Вы не знаете JS* (*YDKJS*) представляет разительный контраст с типичными подходами к изучению JS и непохожа практически на любые другие книги о JS, которые вы прочтете. Она требует от вас выйти из зоны комфорта и задать серьезные вопросы "почему?" для всех до единой функциональных возможностей, с которыми вы столкнетесь. Вы готовы заняться этой задачей?

Я использую эту последнюю главу, чтобы кратко подвести итог того, чего ждать от оставшихся книг серии и как наиболее эффективно приняться за постройку основы обучения JS держа в своих руках *YDKJS*.

## Область действия и замыкания

Наверное одна из самых фундаментальных вещей, которые понадобятся вам, чтобы быстрее подобраться к этим терминам — это как именно создание области действия переменных на самом деле работает в JavaScript. Недостаточно иметь анекдотичные расплывчатые *представления* об области действия.

Книга *Область действия и замыкания* начинается с развенчания общего ложного представления, что JS — "интерпретируемый язык" и потому не компилируется. А вот и нет!

Движок JS компилирует ваш код прямо перед (а иногда и во время!) выполнением. Поэтому вы пойдете путем более глубокого понимания подхода компилятора к вашему коду, чтобы понять как он находит и разбирается с объявлениями переменных и функций. Попутно, мы посмотрим типичную схему JS по управлению областью действия переменных, "Всплытие (hoisting)."

Именно это критическое понимание "лексической области действия" — то, на чем мы потом будет основывать наше исследование замыкания в последней главе этой книги. Замыкание — возможно, единственное самое важное понятие во всем JS, но если вы сперва не разберетесь плотно как работает область действия, замыкание скорее всего останется вне вашего понимания.

Одно важное применение замыкания — это модульный шаблон, который мы уже кратко представили в этой книге в главе 2. Модульный шаблон, возможно, самый преобладающий шаблон организации кода во всем JavaScript; его глубокое понимание должно быть одним из самых высоких ваших приоритетов.

## this и прототипы объектов

Пожалуй один из самых распространенных и устойчивых ложных фактов о JavaScript — это то, что ключевое слово `this` указывает на функцию, в которой оно появляется. Ужасное заблуждение!

Ключевое слово `this` динамически привязывается основываясь на том как выполняется функция и выясняется, что есть четыре простых правила, чтобы понять и полностью определить привязку `this`.

Тесно связан с ключевым словом `this` механизм прототипов объектов, который является цепочкой поисков свойств, похожих на то, как обнаруживаются переменные в лексической области действия. Но при погружении в прототипы  есть другой большой промах с JS: идея эмуляции (замены) классов и так называемое наследование через прототипы.

К сожалению, желание привнести мышление шаблоном проектирования классов и наследования в JavaScript — это просто наихудшая вещь, которую вы могли бы сделать, несмотря на то, что синтаксис может вводить вас в заблуждение, что есть что-то подобное классам, в действительности механизм прототипов фундаментально противоположен по своему поведению.

Что является предметом спора, так это то, лучше ли проигнорировать несоответствие и притвориться, что вы реализуете "наследование", либо все-таки, что является более подходящим, изучить и принять, то, как на самом деле работает система прототипов объектов. Последнее подходяще именуется "делегированием поведения."

Это больше, чем синтаксическое предпочтение. Делегирование — это совершенно другой и более мощный шаблон проектирования, который сам по себе заменяет необходимость проектировать классы и наследование. Но эти утверждения полностью противоречат почти каждым вторым постам в блогах, книгам и конференциям по этой теме на всем протяжении существования JavaScript.

Претензии, которые я предъявляю касаемо делегирования в противовес наследованию, идут не от нелюбви к языку и его синтаксису, а из желания видеть правильное применение истинной возможности языка и свести на нет бесконечные путаницу и недовольство.

Но объяснение необходимости рассматриваемых прототипов и делегирования гораздо более запутанно, чем то, которое я тут представил. Если вы готовы переосмыслить всё, что как вы думаете вы знаете о "классах" и "наследовании" в JavaScript, я даю вам шанс "принять красную таблетку" (*Матрица*, 1999) и проверить главы 4-6 книги *this & прототипы объектов* этой серии.

## Типы и синтаксис

Третья книга в этой серии в первую очередь фокусируется на разборе еще одной  в высшей степени спорной теме: приведении типов. Возможно, не существует темы, вызывающей большую досаду у разработчиков на JS, чем когда вы говорите о неразберихе, окружающей неявное приведение.

По большей части, общепринятый опыт — то, что неявное приведение это "плохая часть" языка и ее следует избегать любой ценой. По факту, некоторые ушли так далеко, что называют его "дефектом" в дизайне языка. Более того, есть утилиты, чья единственная работа не делать ничего кроме проверки вашего кода и сигнализирования, если вы делаете что-то, даже мало-мальски похожее на неявное приведение.

Но действительно ли приведение — такое сбивающее с толку, такое плохое, такое коварное, что ваш код обречен с самого начала, если вы будете использовать его?

Я отвечаю — нет. После постепенного построения понимания того, как на самом деле работают типы и значения, в главах 1-3, глава 4 берет на себя этот спор и полностью объясняет как работает приведение со всеми его нюансами. Мы увидим какие нюансы приведения действительно удивляют, а какие нюансы на самом деле имеют смысл, если дать время изучить их.

Но я не предполагаю, что приведение только правильное и изучаемое, я утверждаю, что приведение — невероятно полезный и полностью недооцениваемый инструмент, который *вам следует использовать в вашем коде*. Я говорю, что приведение, когда оно используется должным образом, не только работает, но и делает ваш код лучше. Все скептики и спорщики несомненно поднимут на смех такую позицию, но я верю, что это одно из главных направлений, чтобы улучшить вашу игру в JS.

Хотите ли вы просто продолжать следовать тому, что говорит народ или вы желаете не принимать в расчет все допущения и взглянуть на приведение свежим взглядом? Книга *Типы и синтаксис* этой серии заставит вас думать.

## Асинхронность и производительность

Первые три книги этой серии фокусируются на внутренней механике языка, а четвертая книга делает небольшое отступление, чтобы рассмотреть шаблоны, вдобавок к механике языка, для управления асинхронной разработкой. Асинхронность не только критически важна для быстродействия наших приложений, она всё больше становится *тем самым* критическим фактором в легкости написания и обслуживания программы.

Сперва книга начинается с прояснения большей части путаницы с терминологией и подходом вокруг таких вещей как "async", "parallel" и "concurrent" и объясняет в деталях как применять и как не применять такие вещи в JS.

Затем мы двинемся к изучению функций обратного вызова (callback) как к основному методу обеспечения асинхронности. Но тут мы быстро заметим, что сама по себе функция обратного вызова совершенно недостаточна для современных требований к асинхронной разработке. Мы определим два главных недостатка программирования только с помощью функций обратного вызова: потеря доверия к *инверсии управления* (IoC) и нехватка заурядной целесообразности.

Чтобы решить эти два недостатка, ES6 представляет два новых механизма(и даже шаблоны): обещания и генераторы.

Обещания — это независимые от времени обертки вокруг "будущего значения (future value)", которые позволяют вам рассуждать о них и составлять их независимо от того, готово ли уже это будущее значение или еще нет. Более того, они эффективно решают проблемы доверия к IoC маршрутизируя функции обратного вызова посредством доверительного и компонуемого механизма обещаний.

Генераторы представляют новый режим выполнения для функций в JS, в соответствии с которым генератор может быть приостановлен в точках с `yield` и продолжен асинхронно позже. Возможность "приостановка-и-продолжение" позволяет синхронному, последовательно выглядящему коду в генераторе быть обработанным асинхронно за кулисами. Делая так мы устраняем путаницу с нелинейными, нелокальными переходами в функции обратного вызова и таким образом делаем наш асинхронный код синхронно выглядящим, чтобы он был более осмысленным.

Именно эта комбинация обещаний и генераторов и "превращается" в наш самый эффективный шаблон асинхронного кодирования по настоящий момент в JavaScript. Вообще-то, многое из будущих усовершенствований в асинхронности будет в ES7 и позже будет обязательно построено на этой основе. Если серьезно относиться к тому, чтобы эффективно программировать в асинхронном мире, вам понадобится хорошенько освоиться с сочетанием обещаний и генераторов.

Хоть обещания и генераторы и являются почти что явными шаблонами, которые позволяют вашим программам работать более параллельно и таким образом обрабатывать больше за меньший период, в JS есть много других аспектов оптимизации производительности, стоящих изучения.

Глава 5 затрагивает темы, такие как параллелизм программ с помощью Web Workers и параллелизм данных с помощью SIMD, а также техника низкоуровневой оптимизации, как например ASM.js. Глава 6 знакомит с оптимизацией производительности с точки зрения правильных техник оценки производительности, включая то, о каких видах производительности стоит беспокоиться, а какие проигнорировать.

Эффективное программирование на JavaScript означает написание кода, который  может разрушить барьеры ограничений будучи работающим динамически в широком диапазоне браузеров и других средах. Это потребует много сложного и детального планирования и усилий с нашей стороны, чтобы перевести программу с "она работает" на "она работает хорошо".

Книга *Асинхронность и производительность* спроектирована, чтобы дать вам все инструменты и навыки, которые вам понадобятся, чтобы писать адекватный и производительный JavaScript код.

## ES6 и за его пределами

Не важно насколько вы чувствуете себя владеющим JavaScript к этому моменту, правда в том, что JavaScript никогда не прекратит эволюционировать и более того, скорость эволюции быстро растет. Этот факт — это почти что образное представление духа этой серии книг, чтобы проникнуться тем, что мы никогда полностью *не узнаем* каждую часть JS, поскольку как только вы овладеете всем, появятся новые вещи, опускающие границу того, что вам нужно будет изучить.

Эта книга посвящена как краткосрочным, так и среднесрочным перспективам того, в каком направлении идет язык, не только *известные* вещи, как ES6, но и *предполагаемые* вещи за его пределами.

Кроме того, что все книги этой серии включают в себя как составную часть состояние JavaScript на момент написания, которое на полпути к внедрению ES6, основной фокус в серии все-таки больше на ES5. Теперь, мы хотим обратить наше внимание на ES6, ES7 и ...

Поскольку ES6 почти готов на момент написания этих строк, *ES6 и за его пределами* начинается с того, что делится практическими вещами из пространства ES6 в нескольких ключевых категориях, включая новый синтаксис, новые структуры данных (коллекции) и новые возможности обработки и API. Мы рассмотрим каждую из этих новых возможностей ES6 на различных уровнях детализации, включая рассмотрение деталей, которые затрагиваются в других книгах серии.

Вот некоторые захватывающие вещи в ES6, про которые вы будете с нетерпением ждать, чтобы прочесть: деструктурирование (destructuring), значения параметров по умолчанию, символы, сокращенные методы (concise methods), вычисляемые свойства, стрелочные функции (arrow functions), блочная область действия, обещания (promises), генераторы, итераторы, модули, прокси, слабосвязанные коллекции ключ-значение (weakmaps) и многое, многое другое! Ну и ну, ES6 производит огромное впечатление!

Первая часть книги — это дорожная карта по всем вещам, которые вам необходимо изучить, чтобы подготовиться к новому и улучшенному JavaScript, на котором вы будете писать и который будете исследовать в течение следующей пары лет.

Последняя часть книги фокусируется на быстром взгляде на вещи, которые мы можем ожидать в ближайшем будущем в JavaScript. Самая важная мысль здесь в том, что будет после ES6, JS похоже будет эволюционировать компонент за компонентом, а не версия за версией, что означает, что мы можем ожидать увидеть эти вещи ближайшего будущего намного скорее, чем вы могли бы представить себе.

У JavaScript блестящее будущее. Разве сейчас не самое время, чтобы начать изучать его!?

## Обзор

Серия *YDKJS* посвящена утверждению, что все разработчики JS могут и должны изучить все части этого великого языка. Ни одно мнение, никакая надежда на фреймворк и ни один дедлайн проекта не должны быть извинением за то, почему вы так и не изучили и не пришли к глубокому пониманию JavaScript.

Мы возьмем каждое направление в языке и посвятим ему краткую, но очень насыщенную книгу, чтобы полностью исследовать все его части, которые как вам казалось вы знаете, но возможно не полностью.

"Вы не знаете JS" — это не критический разбор или издевательство. Это осознание того, что все мы, включая меня, находим общий язык. Изучение JavaScript — это не конечная цель, а процесс. Мы не знаем JavaScript, пока что. Но мы узнаем!
