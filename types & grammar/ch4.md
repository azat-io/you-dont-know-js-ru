# Вы не знаете JS: Типы и грамматика
# Глава 4: Преобразование (приведение) типов

Теперь, когда мы гораздо более полно понимаем типы и значения в JavaScript, обратим наше внимание на очень спорную тему: преобразование типов.

Как было упомянуто в главе 1, споры о том, является ли преобразование типов полезной фичей или недостатком в дизайне языка (или где-то посередине!), бушуют с первого дня его существования. Если вы читали другие популярные книги по JS, вы знаете, что у подавляющего большинства авторов распространено мнение, что преобразование типов - это что-то магическое, злое, сбивающее с толку и просто совершенно плохая идея.


В том же общем духе этой серии книг, вместо того, чтобы убегать от преобразования типов, потому что все остальные так делают, я думаю, вам следует стремиться понять в большей степени то чего вы не понимаете.

Наша цель - полностью изучить плюсы и минусы (да, плюсы есть!) преобразования типов, чтобы вы могли принять обоснованное решение о его целесообразности в вашей программе.

## Преобразование значений

Преобразование значения из одного типа в другой бывает явным ("type casting") и не явным ("coercion") (происходит принудительно по правилам использования этого значения).

**Примечание:** Это может быть неочевидно, но приведения типов JavaScript всегда приводят к одному из скалярных примитивов (см. главу 2): `string`, `number`, или `boolean`. Не существует преобразования, которое приводит к сложному значению, такому как `object` или `function`. Глава 3 охватывает “упаковку”(‘boxing’), которая оборачивает скалярные примитивные значения в их объектные аналоги, но это не совсем приведение в его точном смысле.

Эти термины часто различают по такому принципу: "явное приведение типов" ("type casting"/"type conversion") происходит в статически типизированных языках во время компиляции, тогда как "неявное приведение типов"("type coercion") является преобразованием во время выполнения для динамически типизированных языков.

В любом случае, разница должна быть очевидной: “явное приведение” - это когда при взгляде на код очевидно, что преобразование типа происходит преднамеренно, тогда как "неявное приведение" происходит как менее очевидный побочный эффект какой-либо другой преднамеренной операции.

Например, рассмотрим эти два подхода к преобразованию типов:

```js
var a = 42;

var b = a + "";			// неявное приведение

var c = String( a );	// явное приведение
```

Для `b`приведение происходит неявно, потому что оператор `+` объединенный с одним из операндов, являющимся строковым значением (`""`) будет обозначать, что операция представляет собой конкатенацию строк (сложение двух строк вместе), которая как (скрытый) побочный эффект приведет к приведению значения `42` в `a` к его строковому эквиваленту: `"42"`.

Функция ``String(..)``напротив, делает довольно очевидным, что она явно принимает значение в `a` и приводит его к строковому представлению.

Оба подхода достигают одного и того же эффекта: `"42"` из `42`. Но причина жарких споров по поводу приведения типов в JavaScript, в том *как* это происходит.

**Примечание:** Технически, здесь есть нюансы поведенческой разницы, не только в стилистической. Мы рассмотрим это более подробно позже в этой главе, в разделе “Неявное преобразование: Строки <-> Числа”.

Термины "явный" и "неявный" или "очевидный" и "скрытый побочный эффект" являются *относительными*.

Если вы точно знаете, что делает `a + ""` , и намеренно делаете это для приведения к строке, для вас эта операция достаточно "явная". И наоборот, если вы никогда не видели функцию ``String(..)``, используемую для приведения к строке, ее поведение может показаться достаточно скрытым, "неявным" для вас.

Но мы обсуждаем "явное" и "неявное", основываясь на вероятном мнении *среднего, достаточно информированного разработчика, но не эксперта или автора спецификации JS*. На каком бы уровне вы ни находились, вам необходимо соответствующим образом скорректировать свою точку зрения на наши наблюдения здесь.

Просто помните: мы редко пишем код, единственными читателями которого являемся мы сами. Даже если вы разбираетесь во всех плюсах и минусах JS, подумайте, что будет чувствовать ваш менее опытный товарищ по команде, когда он будет читать ваш код. Будет ли преобразование типов таким же "явным" или "неявным" для него, каким оно является для вас?


## Абстрактные операции со значениями

Прежде чем мы сможем исследовать *явное* и *неявное* преобразование, нам необходимо изучить основные правила, которые определяют, как значения *становятся* `string`, `number`, или `boolean`. Спецификация ES5 в разделе 9 определяет несколько "абстрактных операций" (странный термин спецификации для "внутренних операций") с правилами преобразования значений. Мы особенно обратим внимание на: `ToString`, `ToNumber`, и `ToBoolean`, и, в меньшей степени, на `ToPrimitive`.

### `ToString`

Когда любое не-`string` значение приводится к строковому представлению, преобразование обрабатывается абстрактной операцией `ToString` из раздела 9.8 спецификации.

Встроенные примитивные значения имеют естественное строковое представление: `null` становится `"null"`, `undefined` становится `"undefined"` и `true` становится `"true"`. Числа обычно выражаются естественным образом, как и следовало ожидать, но, как мы обсуждали в главе 2, очень маленькие или очень большие числа представляются в виде экспоненты:


```js
// умножение `1.07` на `1000` семь раз подряд
var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;

// семь раз по три цифры => 21 цифра
a.toString(); // "1.07e21"
```

Для обычных объектов, если вы не укажете свой собственный метод, `toString()` (который находится в `Object.prototype.toString()`) по умолчанию вернет *внутренний `[[Class]]`* (см. главу 3), например, `"[object Object]"`.

Но, как сказано ранее, если у объекта есть собственный метод `toString()` и вы используете этот объект в виде строки, автоматически вызывается его `toString()` , и будет использоваться строковый результат этого вызова. 

**Примечание:** То, как объект приводится к строке, технически проходит через абстрактную операцию `ToPrimitive`(спецификация ES5, раздел 9.1), но эти нюансы подробно рассматриваются в разделе `ToNumber` далее в этой главе, поэтому здесь мы их пропустим.

Массивы имеют определенный по умолчанию метод `toString()`который преобразует их в конкатенацию строк всех значений массива (каждое из которых имеет свое строковое представление), с `","` между значениями:

```js
var a = [1,2,3];

a.toString(); // "1,2,3"
```

Опять таки, `toString()`может быть вызван явно или автоматически, если не-`string` используется в строковом контексте.

#### JSON стрингификация

Другая задача, которая кажется ужасно связанной с `ToString` , - это когда вы используете утилиту `JSON.stringify(..)` для сериализации значения в JSON-совместимое строковое значение.

Важно отметить, что это приведение к строке не совсем то же самое, что приведение типов. Но поскольку это связано с приведенными выше правилами `ToString`, мы немного отвлечемся, чтобы охватить здесь поведение JSON стрингификации.

Для большинства простых значений строковая JSON ведет себя в основном так же, как преобразование `toString()`, за тем исключением, что результатом сериализации *всегда является строка*:


```js
JSON.stringify( 42 );	// "42"
JSON.stringify( "42" );	// ""42"" (строка, со строкой в кавычках внутри)
JSON.stringify( null );	// "null"
JSON.stringify( true );	// "true"
```

Любое *JSON-безопасное* значение может быть преобразовано в строку с помощью `JSON.stringify(..)`. Но что значит *JSON-безопасное*? Любое значение, которое может быть корректно представлено в виде JSON.

Может быть проще рассмотреть значения, которые **не являются** JSON-безопасными. Некоторые примеры: `undefined`, `function`, `symbol` (ES6 +) и объекты с циклическими ссылками (где ссылки на свойства в структуре объекта создают бесконечный цикл друг через друга). Все это недопустимые значения для стандартной структуры JSON, в основном потому, что они не переносимы на другие языки, использующие значения JSON.

Утилита `JSON.stringify (..)` автоматически пропускает значения `undefined`, `function` и `symbol`, когда сталкивается с ними. Если такое значение найдено в массиве, это значение заменяется на `null` (чтоб информация о положении в массиве не изменялась). Если оно встретится в свойствах объекта, это свойство будет просто исключено.


Рассмотрим:

```js
JSON.stringify( undefined );					// undefined
JSON.stringify( function(){} );					// undefined

JSON.stringify( [1,undefined,function(){},4] );	// "[1,null,null,4]"
JSON.stringify( { a:2, b:function(){} } );		// "{"a":2}"
```

Но если вы попытаетесь применить `JSON.stringify(..)` к объекту с циклической ссылкой (ссылками) в нем, будет выброшена ошибка.

JSON стрингификация имеет особое поведение: если для значения объекта определен метод `toJSON()`, то, в первую очередь, будет вызван этот метод, чтобы получить значение для использования в сериализации.

Если вы намереваетесь привести к JSON-строке объект, который может содержать недопустимые значения JSON, или если у вас просто есть значения в объекте, которые не подходят для сериализации, вы должны определить для него метод `toJSON()`, который возвращает *JSON-безопасную* версию объекта.

Например:

```js
var o = { };

var a = {
	b: 42,
	c: o,
	d: function(){}
};

// создаем круговую ссылку внутри `a`
o.e = a;

// JSON.stringify( a ) выдаст ошибку о круговой ссылке;

// определим собственный метод для JSON сериализации
a.toJSON = function() {
	// включим в сериализацию только свойство `b`
	return { b: this.b };
};

JSON.stringify( a ); // "{"b":42}"
```

Это очень распространенное заблуждение, что `toJSON()` должен возвращать строковое представление JSON. Это, скорее всего, не так, разве что если вы хотите на самом деле привести строку к строке (обычно нет!). `toJSON()` должен возвращать фактическое обычное значение (любого типа), которое подходит, а сам `JSON.stringify(..)` будет осуществлять стрингификацию.

Другими словами, `toJSON()` следует интерпретировать как "в JSON-безопасное значение, подходящее для строкового преобразования", а не "в JSON-строку", как ошибочно полагают многие разработчики.

Рассмотрим:

```js
var a = {
	val: [1,2,3],

	// возможно правильно!
	toJSON: function(){
		return this.val.slice( 1 );
	}
};

var b = {
	val: [1,2,3],

	// возможно неправильно!
	toJSON: function(){
		return "[" +
			this.val.slice( 1 ).join() +
		"]";
	}
};

JSON.stringify( a ); // "[2,3]"

JSON.stringify( b ); // ""[2,3]""
```

Во втором вызове мы привели к строке возвращаемую строку, а не сам массив, что, вероятно, было не тем, что мы хотели сделать.

Пока мы говорим о `JSON.stringify(..)`, давайте обсудим некоторые менее известные функциональные возможности, которые все еще могут быть очень полезными.

В `JSON.stringify(..)` может быть передан необязательный второй аргумент, который называется *replacer*. Этот аргумент может быть либо массивом, либо функцией. Он используется для настройки рекурсивной сериализации объекта и предоставляет механизм фильтрации, который решает должны свойства включаться или нет, аналогично тому, как `toJSON()` может подготовить значение для сериализации.

Если *replacer* является массивом, это должен быть массив строк, каждая из которых будет указывать имя свойства, которое разрешено включить в сериализацию объекта. Если существует свойство, которого нет в этом списке, оно будет пропущено.

Если *replacer* является функцией, она вызывается один раз для самого объекта, а затем один раз для каждого свойства объекта, в нее каждый раз передается два аргумента, ключ и значение. Чтобы пропустить ключ в сериализации, верните `undefined`. В противном случае верните *предоставленное значение*.

```js
var a = {
	b: 42,
	c: "42",
	d: [1,2,3]
};

JSON.stringify( a, ["b","c"] ); // "{"b":42,"c":"42"}"

JSON.stringify( a, function(k,v){
	if (k !== "c") return v;
} );
// "{"b":42,"d":[1,2,3]}"
```

**Примечание:** В случае когда *replacer* - функция, аргумент ключа `k` - `undefined` для первого вызова (где передается сам объект). Оператор `if` **отфильтровывает** свойство с именем `"c"`. Стрингификация рекурсивна, поэтому в массиве `[1,2,3]` каждое из его значений (`1`, `2`, и `3`) передается в *replacer* как аргумент `v`, а индексы (`0`, `1`, и `2`) - как аргумент `k`.

Третий необязательный аргумент, который также может быть передан в `JSON.stringify(..)` - это *space*, , он используется в качестве отступа для более приятного для пользователя вывода. *Space* может быть положительным целым числом, указывающим, сколько пробелов следует использовать на каждом уровне отступа. Или *space* может быть строкой, и в этом случае для каждого уровня отступа будет использоваться до первых десяти символов его значения.

```js
var a = {
	b: 42,
	c: "42",
	d: [1,2,3]
};

JSON.stringify( a, null, 3 );
// "{
//    "b": 42,
//    "c": "42",
//    "d": [
//       1,
//       2,
//       3
//    ]
// }"

JSON.stringify( a, null, "-----" );
// "{
// -----"b": 42,
// -----"c": "42",
// -----"d": [
// ----------1,
// ----------2,
// ----------3
// -----]
// }"
```

Помните, что `JSON.stringify(..)` не является формой приведения типов. Мы рассмотрели его здесь по двум причинам, которые связывают его поведение с приведением `ToString`:

1. `string`, `number`, `boolean` и `null` значения приводятся в строку JSON в основном так же, как они приводятся к строковым значениям по правилам абстрактной операции `ToString`.
2. Если вы передаете `object` в `JSON.stringify(..)`, и у этого объекта есть метод `toJSON()`, то `toJSON()` автоматически вызывается для (своего рода) "приведения" значения к *JSON-безопасному* перед его стрингификацией.

### `ToNumber`

Если какое-либо не-`number` значение используется таким способом, который требует, чтобы оно было числом, например в математической операции, спецификация ES5 определяет абстрактную операцию `ToNumber` в разделе 9.3.

Например, `true` становится `1`, а `false` становится `0`. `undefined` становится `NaN`, но (что любопытно), `null` становится `0`.

`ToNumber` для строкового значения работает по большей части, как правила/синтаксис для числовых литералов (см. главу 3). Если приведение не удалось, результатом будет `NaN` (вместо синтаксической ошибки, как с числовыми литералами). Одним из примеров различий является то, что восьмеричные числа с префиксом `0` не обрабатываются как восьмеричные числа (а как обычные десятичные) в этой операции, хотя такие восьмеричные значения действительны как числовые литералы (см. главу 2).


**Примечание:** Различия между числовой литеральной грамматикой и `ToNumber` при строковом значении являются тонкими, в них много нюансов, и, следовательно, здесь они не будут рассматриваться. Обратитесь к разделу 9.3.1 спецификации ES5 за дополнительной информацией.

Объекты (и массивы) сначала будут преобразованы в эквивалент их примитивного значения, а результирующее значение (если это примитив, но еще не число) приведено к числу в соответствии с только что упомянутыми правилами `ToNumber`.

Чтобы преобразовать в этот эквивалент примитивного значения, абстрактная операция `ToPrimitive` (спецификация ES5, раздел 9.1) проверит значение (используя внутреннюю операцию `DefaultValue` - спецификация ES5, раздел 8.12.8), чтобы узнать, имеет ли оно `ValueOf()` метод. Если `valueOf()` доступно и возвращает примитивное значение, это значение используется для приведения. Если нет, но доступна функция `toString()`, она предоставит значение для приведения.

Если ни одна операция не может предоставить примитивное значение, выдается ошибка `TypeError`.

Начиная с ES5, вы можете создать такой неприводимый объект - объект без `valueOf()` и `toString()` - если он имеет `null` вместо своего `[[Prototype]]`, обычно с помощью `Object.create(null)`. См. главу "This и Прототипы Объектов" для дополнительной информации о `[[Prototype]]`.

**Примечание:** Мы подробно расскажем о том, как преобразовать в число далее в этой главе, но для следующего фрагмента кода предположим, что функция ``Number(..)`` делает это.

Рассмотрим:

```js
var a = {
	valueOf: function(){
		return "42";
	}
};

var b = {
	toString: function(){
		return "42";
	}
};

var c = [4,2];
c.toString = function(){
	return this.join( "" );	// "42"
};

Number( a );			// 42
Number( b );			// 42
Number( c );			// 42
Number( "" );			// 0
Number( [] );			// 0
Number( [ "abc" ] );	// NaN
```

### `ToBoolean`

Далее давайте немного поговорим о том, как `boolean` ведут себя в JS. Вокруг этой темы много ****путаницы и заблуждений**, так что будьте внимательны!

Прежде всего, у JS есть фактические ключевые слова `true` и `false`, и они ведут себя точно так, как вы ожидаете от логических значений. Это распространенное заблуждение, что значения `1` и `0` идентичны `true`/`false`. Хотя это может быть так в других языках, в JS числа являются числами, а логические значения - логическими. Вы можете привести `1` в `true` (и наоборот) или `0` в `false` (и наоборот). Но они не одинаковы.

#### Значения приводимые к false

Но это не конец истории. Нам нужно обсудить, как ведут себя значения, отличные от двух логических значений, когда вы *приводите их к логическому эквиваленту*.

Все значения JavaScript можно разделить на две категории:

1. значения, которые станут `false`  если преобразовать их в `boolean`
2. все остальные ( которые очевидно, станут `true`)

Это не мое остроумие. Спецификация JS определяет конкретный, узкий список значений, которые станут ложными при приведении к логическому значению.

Как мы узнаем, что это за список? В спецификации ES5 раздел 9.2 определяет абстрактную операцию `ToBoolean`, которая точно говорит, что происходит со всеми возможными значениями, когда вы пытаетесь привести их к булевому значению.

Из этой таблицы мы получаем следующий список значений приводимых к `false`:

* `undefined`
* `null`
* `false`
* `+0`, `-0`, и `NaN`
* `""`

Вот и все. Если значение находится в этом списке, это "ложное" значение, и оно приведётся к `false`, если вы примените к нему преобразование в логический тип.

Следовательно, если значение *не* находится в этом списке, оно должно быть в *другом списке*, который мы назовем *списком значений подобных истине*. Но JS на самом деле не определяет "истинный" список как таковой. В нем приводятся некоторые примеры, такие как явное указание на то, что все объекты являются `true`, но в основном из спецификации просто вытекает: **все, что не указано в списке “ложных” значений, является “истинным”.**

#### Объекты приводимые к false

Подождите минуту, название раздела даже звучит противоречиво. Я *буквально только что* сказал, что спецификация называет все объекты “истинными”, верно? Не должно быть такого понятия, как "объект, приводимый к `false`".

Что бы это могло вообще значить?

Высоко искушение думать, что это означает объект обертку  (см. главу 3) вокруг ложного значения (такого как `""`, `0` или `false`). Но не попадайтесь в эту *ловушку*.


**Примечание:** это тонкая спецификационная шутка, которую некоторые могут заметить.

Рассмотрим:

```js
var a = new Boolean( false );
var b = new Number( 0 );
var c = new String( "" );
```

Мы знаем, что все три значения здесь являются объектами (см. Главу 3), обернутыми вокруг явно ложных значений. Но ведут ли себя эти объекты как истинные или ложные? Это легко проверить:

```js
var d = Boolean( a && b && c );

d; // true
```

Итак, все три ведут себя как `true`, так как это единственный вариант, при котором d может оказаться `true`.

**Подсказка:** обратите внимание на `Boolean(..)`, в которое обернуто выражение `a && b && c` - вы можете удивиться, почему оно там. Мы вернемся к этому позже в этой главе, так что запомним это. Ради любопытства, попробуйте для себя узнать чем будет `d`, если вы просто сделаете `d = a && b &&` c без вызова `Boolean(..)`!

Итак, если объекты подобные ложным - **это не просто объекты, обернутые вокруг ложных значений**, то что же они такое?

Сложность в том, что они могут отображаться в вашей программе JS, но на самом деле они не являются частью самого JavaScript.


**What!?**

Есть определенные случаи, когда браузеры создали свое поведение с *экзотическими* значениями, а именно эту идею "ложных объектов", поверх обычной семантики JS.

"Ложный объект" - это значение, которое выглядит и действует как обычный объект (свойства и т. д.), но когда вы приводите его к логическому типу, оно становится ложным.


**Why!?**

Наиболее известным примером является `document.all`: массивоподобный объект, *предоставленный вашей JS-программе DOM* (а не самим JS-движком), который предоставляет элементы на странице вашей JS-программе. Раньше он вел себя как обычный объект - был `true`. Но больше нет.

Сам по себе `document.all` никогда не был "стандартным" и давно устарел.

"В таком случае, разве они не могут просто удалить его?" Хорошая попытка. Хотелось бы. Но существует слишком много устаревшего JS-кода, который его использует.

Итак, зачем делать его “ложным”? Потому что приведение `document.all` к булевому типу (как в операторах `if`) почти всегда использовалось как средство обнаружения старого, нестандартного IE.

Итак, зачем делать его “ложным”? Потому что приведение document.all к булевому типу (как в операторах if) почти всегда использовалось как средство обнаружения старого, нестандартного IE.

IE уже давно пришел к соответствию стандартам и во многих случаях продвигает веб вперед так же, как любой другой браузер. Но весь этот старый код `if (document.all) {/ * это IE * /}` все еще существует, и большая его часть, вероятно, никогда не исчезнет. Весь этот унаследованный код все еще предполагает, что он работает в IE десятилетней давности, что просто приводит к плохим возможностям просмотра для пользователей IE.

Таким образом, мы не можем полностью удалить document.all, но IE не хочет, чтобы код `if (document.all) {..}` работал, чтобы пользователи в современном IE получали новую, совместимую со стандартами логику кода.

"Что нам делать?" ** "Я понял! Давайте проигнорируем систему типов JS и представим, что `document.all` - `false`!"

Тьфу. Это отстой. Это сумасшедшая ошибка, которую большинство разработчиков JS не понимают. Но альтернатива (ничего не делать с вышеупомянутыми проблемами) отстой чуть-чуть больше.

Итак ... вот что у нас получилось: сумасшедшие нестандартные "ложные объекты", добавленные в JavaScript браузерами. Ура!

#### Truthy Values

Вернемся к списку “истинных” значений. Чем вообще являются “истинные” значения? Помните: **значение является `true`, если его нет в списке `false` значений.**

Рассмотрим:

```js
var a = "false";
var b = "0";
var c = "''";

var d = Boolean( a && b && c );

d;
```

Какой результат вы ожидаете здесь? Либо `true`, либо `false`.

Это `true`. Почему? Поскольку, несмотря на то, что содержимое этих строковых значений выглядит как ложные значения, сами строковые значения являются истинными, потому что `""` - это единственное строковое значение в списке ложных значений.

Что на счет этого?

```js
var a = [];				// пустой массив -- true или false?
var b = {};				// пустой объект -- true или false?
var c = function(){};	// пустая функция-- true или false?

var d = Boolean( a && b && c );

d;
```

Да, вы уже догадались, `d` все еще `true` здесь. Почему? Та же причина, что и раньше. Несмотря на то, чем они кажутся, `[]`, `{}` и `function() {}` *отсутствуют* в списке ложных значений и, следовательно, являются истинными.

Другими словами, “истинный” список бесконечно длинный. Невозможно составить такой список. Можно составить только конечный “ложный” список и обращаться к нему.

Потратьте пять минут, выпишите“ложный” список на стикер и приклейте на монитор или запомните его, если хотите. В любом случае, вы легко сможете создать виртуальный “истинный” список, когда вам это нужно, просто спросив, есть ли это значение в списке ложных или нет.

Важность истинности и ложности заключается в понимании того, как будет вести себя значение, если вы приведете его (явно или неявно) к логическому типу. Теперь, когда у вас есть эти два списка, мы можем погрузиться в примеры приведения типов.

## Явное преобразование типов

Существует множество вариантов использования преобразования типов, которые подпадают под категорию *явного* для большинства разработчиков.

Цель здесь состоит в том, чтобы определить шаблоны в нашем коде, где мы можем четко и ясно указать, что мы преобразуем значение из одного типа в другой, чтобы не вводить в заблуждение будущих разработчиков. Чем более очевиден наш код, тем выше вероятность, что кто-то позже сможет понять без лишних усилий, каково было наше намерение.

Было бы трудно найти какие-либо существенные разногласия с явным преобразованием, поскольку оно наиболее точно согласуется с тем, как общепринятая практика преобразования типов работает в статически типизированных языках. Таким образом, будем считать (на данный момент), что *явное* преобразование не такое уж коварное и противоречивое. Хотя, мы вернемся к этому позже.

### Явно: Строки <-> Числа

Мы начнем с самой простой и, возможно, самой распространенной операции приведения: приведения значений из строки в число и наоборот.

Для преобразования между строками и числами мы используем встроенные функции ``String(..)`` и ``Number(..)`` (которые мы называли "нативными конструкторами" в главе 3), но, что очень важно, мы не используем ключевое слово new перед ними. Таким образом, мы не создаем объектные обертки.

Вместо этого мы на самом деле выполняем *явное* преобразование между двумя типами:

```js
var a = 42;
var b = String( a );

var c = "3.14";
var d = Number( c );

b; // "42"
d; // 3.14
```

`String(..)` преобразует любое другое значение в строковое примитивное значение, используя правила операции `ToString`, обсуждавшиеся ранее. `Number(..)` преобразует любое другое значение в числовое примитивное значение, используя правила операции `ToNumber`, обсуждавшиеся ранее.

Я называю это явным приведением, потому что в большинстве случаев для большинства разработчиков довольно очевидно, что конечным результатом этих операций является преобразование типов.

Фактически, это выглядит во многом как в некоторых статически типизированных языках.

Например, в C / C ++ можно вызвать `(int) x`, или `int (x)`, и оба преобразуют значение x в целое число. Обе формы действительны, но многие предпочитают последнюю, которая выглядит как вызов функции. В JavaScript вы вызываете `Number(x)` - очень похоже. Важно ли, что в JS - это на *самом деле вызов функции*? В общем-то, нет.

Помимо `String(..)` и `Number(..)`, есть и другие способы "явного" преобразования между строкой и числом:

```js
var a = 42;
var b = a.toString();

var c = "3.14";
var d = +c;

b; // "42"
d; // 3.14
```

Вызов `a.toString ()` якобы является явным (довольно ясно, что "toString" означает "в строку"), но здесь есть некоторая неявность. `toString()` не может быть вызван для простого значения, такого как 42. Таким образом, JS автоматически "упаковывает" (см. главу 3) `42` в объект-обертку, чтобы `toString()` был вызван у объекта. Можете считать это преобразование “явно неявным”.

`+c` здесь показывает форму *унарного* оператора `+` (оператор только с одним операндом). Вместо математического сложения (или конкатенации строк - см. ниже), унарный `+` явно приводит свой операнд `(c)` к числовому значению.

Является ли `+c` *явным* приведением? Зависит от вашего опыта и взглядов. Если вы знаете (а теперь точно знаете!), что унарный `+` явно предназначен для приведения к числу, то это довольно *явно* и очевидно. Однако, если вы никогда не видели его раньше, это может показаться странным, неявным, со скрытыми побочными эффектами и т. д.

**Примечание:** То, что унарный `+` является формой явного преобразования типов - это общепринятая точка зрения в JS-сообществе.

Даже если вам нравится форма `+c`, есть места, где она может выглядеть ужасно запутанно. Рассмотрим:

```js
var c = "3.14";
var d = 5+ +c;

d; // 8.14
```

Унарный оператор `-` также приводит к числу, как `+`, но он также меняет знак числа. Тем не менее, вы не можете поставить два `--` рядом друг с другом, чтобы вернуть знак, поскольку это анализируется как оператор декремента. Вместо этого вам необходимо выполнить: `- -"3.14"` с пробелом между ними, и это приведет к числу `3.14`.

Вероятно, вы можете придумать всевозможные отвратительные комбинации бинарных операторов (например, `+` для сложения) рядом с унарной формой оператора. Вот еще один сумасшедший пример:

```js
1 + - + + + - + 1;	// 2
```

Вы должны строго избегать унарного `+` (или `-`) для приведения типа, когда оно непосредственно соседствует с другими операторами. Хотя вышесказанное работает, это почти повсеместно будет считаться плохой идеей. Даже `d =+ c` легко спутать с `d += c`, что является совершенно другой операцией!

**Примечание:** Другим крайне запутанным местом использования унарного `+` рядом с другим оператором может быть оператор инкремента `++` и оператор декремента `--`. Например: `a +++ b`, `a + ++ b` и `a +++ b`. См. "Побочные эффекты выражений" в главе 5 насчет `++`.

Помните, мы **стараемся сделать код явным и уменьшить путаницу**, а не сделать хуже!

#### `Date` в `number`

Другое распространенное использование унарного оператора `+` - это приведение объекта `Date` к числу, поскольку результатом является представление даты / времени в unix timestamp (прошедшее с 1 января 1970 года, 00:00:00 UTC):


```js
var d = new Date( "Mon, 18 Aug 2014 08:53:06 CDT" );

+d; // 1408369986000
```

Наиболее распространенное использование этого выражения состоит в том, чтобы получить *текущий момент* в качестве отметки времени, например:

```js
var timestamp = +new Date();
```

**Примечание:** Некоторым разработчикам известно о своеобразной синтаксической "хитрости" JavaScript, которая заключается в том, что пару скобок в вызове конструктора (функция, вызываемая с помощью new), можно *опустить*, если нет передаваемых аргументов. Таким образом, вы можете встретить `var timestamp = + new Date`. Однако не все разработчики согласны с тем, что пропуск скобок улучшает читабельность, поскольку это необычное синтаксическое исключение, которое применяется только к форме вызова `new Fn()`, а не к обычной форме вызова `fn()`.

Но преобразование типа - не единственный способ получить отметку времени из объекта `Date`. Подход без преобразования, возможно, даже предпочтительнее, поскольку он еще более явный:


```js
var timestamp = new Date().getTime();
// var timestamp = (new Date()).getTime();
// var timestamp = (new Date).getTime();
```

И даже еще более предпочтительно использовать `Date.now()` (из ES5):

```js
var timestamp = Date.now();
```

А если вам нужен полифилл для `Date.now()` для более старых браузеров, он довольно простой:


```js
if (!Date.now) {
	Date.now = function() {
		return +new Date();
	};
}
```

Я бы рекомендовал избегать преобразования типов, связанные с датами. Используйте `Date.now()` для временной отметки в *данный момент*, а `new Date(..).getTime()` для получения временной отметки *определенной даты / времени.*

#### Загадочный случай `~`

Одним из операторов приведения типов JS, который часто упускается из виду и сбивает с толку, является оператор тильда `~` (он же "побитовое НЕ"). Многие из тех, кто даже понимает, что он делает, часто хотят избежать его. Но придерживаясь нашего подхода в этой книге и серии, давайте посмотрим, как он работает, чтобы выяснить, есть ли в нем что-нибудь полезное для нас.

В разделе "32-битные целые числа (со знаком)" главы 2 мы рассмотрели, что побитовые операторы в JS определены только для 32-разрядных операций, что означает, что они заставляют свои операнды соответствовать представлениям 32-разрядных значений. Правила того, как это происходит, контролируются абстрактной операцией `ToInt32` (спецификация ES5, раздел 9.5).

`ToInt32` сначала выполняет приведение `ToNumber`, что означает, что если значение равно `"123"`, оно сначала станет `123`, прежде чем будут применены правила `ToInt32`.

Хотя *технически* это не приведение типа (поскольку тип не меняется!), Использование побитовых операторов (таких как `|` или `~`) с определенными специальными числовыми значениями приводят к эффекту приведения типа, который приводит к другому числовому значению.

Например, давайте сначала рассмотрим `|` оператор "побитовое ИЛИ", используемый в выражении без операции `0 | x`, который (как показано в главе 2), по сути, выполняет только преобразование `ToInt32`:


```js
0 | -0;			// 0
0 | NaN;		// 0
0 | Infinity;	// 0
0 | -Infinity;	// 0
```

Эти специальные числа не являются 32-битными представлениями (поскольку они получены из 64-битного стандарта IEEE 754 - см. Главу 2), поэтому `ToInt32` просто указывает 0 как результат этих значений.

Спорно, является ли `0 | __` *явным* преобразованием операции `ToInt32` или неявным. С точки зрения спецификации, безусловно, явным, но если вы не понимаете побитовые операции на этом уровне, это может показаться скорее неявным, волшебным. Тем не менее, в соответствии с другими утверждениями в этой главе, мы будем называть его явным.

Итак, вернемся к `~`. Оператор `~` сначала "приводит" к значению 32-битного числа, а затем выполняет побитовое отрицание (переключение значения каждого бита).

**Примечание:** это очень похоже на то, как операция `!` не только приводит значение с ним к логическому типу, но также инвертирует его (см. обсуждение "унарный `!`" позже).

Но…. к чему это все!? Почему мы говорим о переключении четности битов? Это довольно специфические нюансы. Разработчикам JS редко приходится задумываться об отдельных битах.

Другой подход к определению `~` исходит из старой школы информатики/дискретной математики: `~` выполняет преобразование в дополнительный код(второе дополнение). Отлично, спасибо, все стало понятно!

Давайте попробуем еще раз: `~ x` примерно то же, что `-(x + 1)`. Это странно, но немного проще. Так что:



```js
~42;	// -(42+1) ==> -43
```

Вы, вероятно, все еще задаетесь вопросом, о чем, черт возьми, все это, или почему это так важно для обсуждения приведения типов. Давайте скорее доберемся до сути.

Рассмотрим `-(x + 1)`. Какое единственное значение, с которым вы можете выполнить эту операцию, даст `0` (или `-0` технически!)? `-1`. Другими словами,`~`, используемая с некоторым диапазоном числовых значений, вернет значение `0`, которое приводится к `false`, для входного значения `-1` и вернет любое другое число, приводимое к `true`, в противном случае.

Почему это актуально?

`-1` обычно называют "сторожевым значением", т.е значением, в которое вложен произвольный семантический смысл в пределах большего множества значений того же типа (чисел). Язык C использует значение `-1` для многих функций, которые возвращают значения `>= 0` в случае "успеха" и `-1` в противном случае.

JavaScript принял этот прецедент в определении строковой операции `indexOf(..)`, которая ищет подстроку и, если она найдена, возвращает позицию индекса, начинающуюся с нуля, а если нет -  `-1`.

Довольно часто пытаются использовать `indexOf(..)` не только как операцию для получения позиции, но и как логическую проверку наличия / отсутствия подстроки в другой строке. Вот как разработчики обычно выполняют такие проверки:

```js
var a = "Hello World";

if (a.indexOf( "lo" ) >= 0) {	// true
	// found it!
}
if (a.indexOf( "lo" ) != -1) {	// true
	// found it
}

if (a.indexOf( "ol" ) < 0) {	// true
	// not found!
}
if (a.indexOf( "ol" ) == -1) {	// true
	// not found!
}
```

На мой взгляд, это немного грубо - проверять `>= 0` или `== -1`. По сути, это "дырявая абстракция", в которой просачивается базовое поведение реализации - использование `-1` для "неудачи" - в моем коде. Я бы предпочел скрыть это.

И вот, наконец, мы понимаем, почему `~` может помочь нам! Использование `~` с `indexOf()` преобразует значение в соответствующий **удобный для логического преобразования вид**:

```js
var a = "Hello World";

~a.indexOf( "lo" );			// -4   <-- приводимый к true!

if (~a.indexOf( "lo" )) {	// true
	// нашел!
}

~a.indexOf( "ol" );			// 0    <-- приводимый к false!
!~a.indexOf( "ol" );		// true

if (!~a.indexOf( "ol" )) {	// true
	// не нашел!
}
```

`~` принимает возвращаемое значение `indexOf(..)` и преобразует его: для "отказа" `-1 `мы получаем “ложное” значение `0`, а все остальные значения “истинные”.

**Примечание:** Псевдоалгоритм `-(x + 1)` для `~` подразумевает, что `~ -1` равен `-0`, но на самом деле выдает `0`, потому что операция в его основе на самом деле является побитовой, а не математической.

Технически, `if (~ a.indexOf (..))` все еще полагается на неявное приведение его результата `0` к `false`, а ненулевое значение к true. Но, в целом, я считаю `~` скорее механизмом *явного* преобразования, если знать, что он делает в этом выражении.

Я считаю, что это более чистый код, чем предыдущий -  `>= 0` / `== -1`.


##### Отсекание битов

Есть еще одно место в коде, где вы можете столкнуться с `~` : некоторые разработчики используют двойную тильду `~~` для усечения десятичной части числа (т.е. "приводят" к целому числу). Обычно (хотя и ошибочно) говорят, что это то же, что и вызов `Math.floor(..)`.

`~~` работает следующим образом, первая `~` применяет "преобразование" `ToInt32` и осуществляет побитовое инвертирование, а затем вторая `~` переворачивает все биты обратно в исходное состояние. Конечным результатом является просто `ToInt32` "преобразование" (также называемое отсечение дробной части).


**Примечание:** Побитовое двойное инвертирование `~~` очень похоже на двойное отрицание `!!`, объясняемое в разделе "Явно: * --> Boolean" далее.

Тем не менее, `~~` требует осторожности/уточнения. Во-первых, это надежно работает только с 32-битными значениями. Но что еще более важно, с отрицательными числами работает не так, как `Math.floor(..)`!


```js
Math.floor( -49.6 );	// -50
~~-49.6;				// -49
```

Помимо отличия от `Math.floor(..)`, `~~ x` может усечь (32-разрядное) целое число. Но и `х | 0` это делает, казалось бы, с (немного) меньшими усилиями.

Итак, зачем тогда использовать `~~ x` а не `x | 0` ? Приоритет оператора (см. главу 5):


```js
~~1E20 / 10;		// 166199296

1E20 | 0 / 10;		// 1661992960
(1E20 | 0) / 10;	// 166199296
```

Как и в случае с любыми другими советами здесь, используйте `~` и `~~` как явные механизмы для "приведения" и преобразования значения, только если каждый, кто будет читать / писать этот код, наверняка знает, как работают эти операторы!

### Явно: Парсинг числовых строк

Результат, аналогичный приведению строки к числу, может быть достигнут путем парсинга числа из содержимого строки. Однако есть четкие различия между этим парсингом и преобразованием типов, которое мы рассмотрели выше.

Рассмотрим:

```js
var a = "42";
var b = "42px";

Number( a );	// 42
parseInt( a );	// 42

Number( b );	// NaN
parseInt( b );	// 42
```

Парсинг числового значения из строки допускает нечисловые символы - он просто прекращает синтаксический анализ слева направо, когда они встречаются, в то время как приведение типов не допускает их и прекращается, что приводит к значению `NaN`.

Парсинг не следует рассматривать как замену приведения. Эти две задачи, хотя и схожи, имеют разные цели. Вы можете парсить строку как число, если вы не знаете/ вам не важно, какие другие нечисловые символы могут быть справа. Приводите строку к числу, когда единственно допустимые значения являются числовыми и что-то вроде `"42px"` должно быть отклонено.


**Подсказка:** `parseInt(..)` имеет двойника `parseFloat(..)`, который (как и следует из названия) парсит число с плавающей точкой из строки.

Не забывайте, что `parseInt(..)` работает со строковыми значениями. Абсолютно бессмысленно передавать числовое значение в `parseInt(..)`. Также не имеет смысла передавать любой другой тип значения, например true, `function() {..}` или `[1,2,3]`.

Если вы передаете не строковое значение, то передаваемое вами значение будет автоматически приведено к строке вначале (см. "ToString" ранее), что точно будет неким скрытым, неявным приведением типа. Очень плохая идея полагаться на такое поведение в вашей программе, поэтому никогда не используйте `parseInt(..)` с не-строковым значением.

До ES5 был еще один момент с `parseInt(..)`, который был источником ошибок многих программ JS. Если вы не передали второй аргумент, чтобы указать, какое числовое основание (иначе называемое radix) использовать для интерпретации содержимого числовой строки, `parseInt(..)` будет искать начальные символы, чтобы сделать предположение.

Если первые два символа были "0x" или "0X", предположение (по соглашению) состояло в том, что вы хотели интерпретировать строку как шестнадцатеричное (base-16) число. В противном случае, если первый символ был "0", предположение (опять же по соглашению) состояло в том, что вы хотели интерпретировать строку как восьмеричное (base-8) число.

Шестнадцатеричные строки (начинающиеся с 0x или 0X) не очень легко перепутать. Но угадывание восьмеричных чисел оказалось чертовски распространенным.

```js
var hour = parseInt( selectedHour.value );
var minute = parseInt( selectedMinute.value );

console.log( "The time you selected was: " + hour + ":" + minute);
```

Кажется безобидным, верно? Попробуйте выбрать `08` часов и `09` минут. Вы получите `0:0`. Почему? потому что ни `8`, ни `9` не являются действительными символами в восьмеричной системе (base-8).

Исправление до ES5 было простым, но оно легко забывалось: всегда передавайте `10` в качестве второго аргумента. Это было абсолютно безопасно:


```js
var hour = parseInt( selectedHour.value, 10 );
var minute = parseInt( selectedMiniute.value, 10 );
```

Начиная с ES5, `parseInt(..)` больше не угадывает восьмеричные значения. Он принимает base-10 (или base-16 для префиксов "0x"). Это намного лучше. Просто будьте осторожны, если ваш код должен работать в средах, предшествующих ES5, в этом случае вам нужно передавать 10 вторым аргументом.

#### Парсинг не-строк

Один печально известный пример поведения `parseInt(..)` выделен в саркастической статье-шутке несколько лет назад, высмеивающей это поведение JS:

```js
parseInt( 1/0, 19 ); // 18
```

Предполагаемое (но совершенно неверное) утверждение было: "Если я передам в бесконечность, чтобы спарсить из нее целое число, `parseInt(..)` должен вернуть бесконечность, а не `18`". Конечно, JS наверное ненормальный, раз возвращает такой результат, верно?

Хотя этот пример явно надуманный и нереальный, давайте на мгновение потворствуем безумию и исследуем, действительно ли JS такой сумасшедший.

Во-первых, самый очевидный грех, совершенный здесь, это передача не-строки в `parseInt(..)`. Это табу. Сделай это, и ты нарвешься на неприятности. Но даже если вы это сделаете, JS вежливо преобразует то, что вы передаете, в строку, которую он может попытаться проанализировать.

Некоторые утверждают, что это неоправданное поведение, и что `parseInt(..)` должен отказаться работать с не-строковым значением. Должен ли он выдавать ошибку? Откровенно говоря, это было бы очень похоже на Java. Я вздрагиваю, думая, что JS может начать разбрасывать ошибки повсюду, так что `try..catch` потребуется почти в каждой строке.

Должен ли он вернуть `NaN`? Может быть. Но что насчет:

```js
parseInt( new String( "42") );
```

Тут тоже должна быть ошибка? Это не строковое значение. Если вы хотите, чтобы объект-обертка `String` был распакован в `"42"`, то действительно ли так необычно, что `42` сначала становится `"42"`, чтобы `parseInt`  его спарсил?

Я бы сказал, что это частично явное, частично неявное преобразование, которое часто может быть очень полезным. Например:


```js
var a = {
	num: 21,
	toString: function() { return String( this.num * 2 ); }
};

parseInt( a ); // 42
```

Тот факт, что `parseInt(..)` принудительно приводит свое значение к строке для выполнения анализа, вполне разумен. Если вы выбрасываете мусор в бак и то, что вы достали из него обратно тоже оказалось мусором, не вините мусорный бак - он просто добросовестно выполнил свою работу.

Итак, если вы передадите значение вроде `Infinity` (результат `1/0`), какое строковое представление будет наиболее целесообразным для его приведения? На ум приходят только два разумных варианта: `"Infinity"` и `"∞"`. JS выбрал `"Infinity"`. Я рад, что он это сделал.

Я думаю, это хорошо, что все значения в JS имеют своего рода **строковое представление по умолчанию**, так что они не являются таинственными черными ящиками, которые мы не можем отлаживать и осознавать.

А что насчет base-19? Очевидно, это был совершенно фальшивый и надуманный пример. Никакие настоящие программы JS не используют base-19. Это абсурд. Но опять же, давайте потворствовать нелепости. В base-19 допустимыми числовыми символами являются 0 - 9 и a - i (без учета регистра).

Итак, вернемся к нашему примеру `parseInt(1/0, 19)`. По сути, это `parseInt("Infinity", 19)`. Как он будет это парсить? Первый символ - `"i"`, значение `18` в нелепом base-19. Второго символа `"n"` нет в допустимом наборе числовых символов, и поэтому анализ просто вежливо прекращается, точно так же, как когда он перебирает `"p"` в `"42px"`.

Результат? `18`. Вполне разумный результат. Поведение, используемое для того, чтобы получить его, а не ошибку или саму бесконечность, **очень важно для JS**, и от него не так легко отказаться.

Другие примеры такого поведения с `parseInt(..)`, которые могут быть удивительными, но вполне разумными, включают:


```js
parseInt( 0.000008 );		// 0   ("0" from "0.000008")
parseInt( 0.0000008 );		// 8   ("8" from "8e-7")
parseInt( false, 16 );		// 250 ("fa" from "false")
parseInt( parseInt, 16 );	// 15  ("f" from "function..")

parseInt( "0x10" );			// 16
parseInt( "103", 2 );		// 2
```

`parseInt(..)` на самом деле довольно предсказуемый и последовательный в своем поведении. Если вы используете его правильно, вы получите разумные результаты. Если вы используете его неправильно, полученные вами сумасшедшие результаты не являются ошибкой JavaScript.

### Явно: * --> Boolean

Теперь давайте рассмотрим приведение любого не-`boolean` значения к `boolean`.

Как и в случае с `String(..)` и `Number(..)` выше, `Boolean(..)` (конечно, без `new`!) - это явный способ спровоцировать приведение `ToBoolean`:

```js
var a = "0";
var b = [];
var c = {};

var d = "";
var e = 0;
var f = null;
var g;

Boolean( a ); // true
Boolean( b ); // true
Boolean( c ); // true

Boolean( d ); // false
Boolean( e ); // false
Boolean( f ); // false
Boolean( g ); // false
```

Хотя `Boolean(..)` явный, он не распространен.

Так же, как унарный оператор `+` приводит значение к числу (см. Выше), унарный `!`  оператор отрицания явно приводит к логическому значению. Проблема в том, что он также меняет значение с правдивого на ложное или наоборот. Таким образом, наиболее распространенный способ, которым разработчики JS явно приводят к булевому значению, - это использование `!!` оператор двойного отрицания, потому что второй `!` вернет правдивость или ложность обратно к оригиналу:


```js
var a = "0";
var b = [];
var c = {};

var d = "";
var e = 0;
var f = null;
var g;

!!a;	// true
!!b;	// true
!!c;	// true

!!d;	// false
!!e;	// false
!!f;	// false
!!g;	// false
```

Любое из этих приведений ToBoolean могло бы происходить *неявно* без `Boolean(..)` или `!!`, если бы оно использовалось в логическом контексте, таком как оператор `if (..)`. Но цель здесь состоит в том, чтобы явным образом преобразовать значение в булевый тип, чтобы прояснить, что происходит преобразование `ToBoolean`.

Другой пример использования явного приведения `ToBoolean`, если вы хотите установить истинное / ложное значение в сериализации JSON структуры данных:


```js
var a = [
	1,
	function(){ /*..*/ },
	2,
	function(){ /*..*/ }
];

JSON.stringify( a ); // "[1,null,2,null]"

JSON.stringify( a, function(key,val){
	if (typeof val == "function") {
		// применить преобразование `ToBoolean` для функций
		return !!val;
	}
	else {
		return val;
	}
} );
// "[1,true,2,true]"
```

Если вы пришли в JavaScript из Java, вы можете узнать это выражение:

```js
var a = 42;

var b = a ? true : false;
```

`? :` тернарный оператор проверит a на истинность, и на основании этой проверки присвоит `b`, либо `true`, либо `false`, соответственно.

На первый взгляд, это выражение выглядит как форма явного приведения типа `ToBoolean`, поскольку очевидно, что из операции следует только true или `false`.

Однако существует скрытое, неявное приведение, в котором выражение a должно быть сначала приведено к логическому значению, чтобы выполнить на нем проверку. Я бы назвал это выражение "явно-неявным". Кроме того, я бы посоветовал **вам полностью избегать этого выражения** в JavaScript. В нем нет никакой реальной выгоды, и, что еще хуже, оно маскируется под то, чем оно не является.

`Boolean(a)` и `!!` a намного лучше, в качестве явных способов приведения.

## Неявное преобразование

*Неявное* преобразование означает приведение типов с неочевидными побочными эффектами, которые скрыто происходят от других действий. Другими словами, неявные - любые преобразования типов, которые не очевидны (для вас).

Ясно, какова цель явного преобразования (сделать код более понятным), может показаться, что *неявное* преобразование имеет противоположную цель: сделать код труднее для понимания.

Если принять это за чистую монету, я полагаю, что именно отсюда происходит гнев в адрес преобразования типов. Большинство жалоб на приведение типов JavaScript на самом деле касаются (не важно понимают это те, кто жалуются, или нет) на *неявного* приведения.

**Примечание:** Дуглас Крокфорд, автор "JavaScript: The Good Parts", заявлял во многих выступлениях и публикациях на конференциях, что приведения типов в JavaScript следует избегать (по его мнению). Но он, похоже, имел в виду неявное преобразование. Однако, если вы прочитаете его код, вы найдете множество примеров приведения типов, как явного, так и не явного! По правде говоря, его беспокойство в первую очередь направлено на операцию `==`, но, как вы увидите в этой главе, это только часть механизма приведения типов.

Итак, **является ли неявное приведение злом**? Оно опасно? Это недостаток в дизайне JavaScript? Должны ли мы избегать его любой ценой?

Могу поспорить, что большинство из вас, читатели, склонны с энтузиазмом утверждать: "Да!"

**Не так быстро**. Выслушайте меня.

Давайте рассмотрим иной взгляд на то, что такое неявное приведение, а не просто на то, что оно "противоположно хорошему явному". Это слишком узко и пропускает важный нюанс.

Давайте определим цель неявного приведения так: уменьшить многословность, нефункциональный код (бойлерплейт), и / или скрыть ненужные детали реализации, которые загромождают наш код шумом и отвлекает от более важных вещей.

### Упрощая неявное

Прежде чем мы вообще перейдем к JavaScript, позвольте мне предложить немного псевдокода из некоторого теоретического строго типизированного языка, для иллюстрации:

```js
SomeType x = SomeType( AnotherType( y ) )
```

В этом примере у меня есть некоторый произвольный тип значения в y, который я хочу преобразовать в тип `SomeType`. Проблема в том, что этот язык не может напрямую перейти от того, что у вас есть к `SomeType`. Требуется промежуточный шаг, где он сначала преобразуется в `AnotherType`, а затем из `AnotherType` в `SomeType`.

А что если этот язык (или определение, которое вы могли бы создать самостоятельно с помощью языка) просто позволял бы вам сказать:


```js
SomeType x = SomeType( y )
```

Разве вы не согласны с тем, что мы упростили преобразование типов здесь, чтобы уменьшить ненужный "шум" промежуточного этапа преобразования? Я имею в виду, действительно ли это так важно, прямо здесь, на этом этапе кода, видеть и иметь дело с тем фактом, что y сначала переходит к `AnotherType`, а затем переходит к `SomeType`?

Некоторые будут спорить, по крайней мере, в некоторых обстоятельствах, да. Но я думаю, что можно привести равный аргумент о многих других обстоятельствах, в которых **это повышает удобочитаемость кода**, абстрагируя или скрывая такие детали, либо в самом языке, либо в наших собственных абстракциях.

Несомненно, где-то за кулисами промежуточный шаг преобразования все еще происходит. Но если эта деталь скрыта от глаз, мы можем просто думать о том, чтобы  y привелся к `SomeType` с помощью обычной операции, и скрыть беспорядочные детали.

Хотя это и не идеальная аналогия, я буду спорить в оставшейся части этой главы о том, что неявное преобразование типов JS можно рассматривать как предоставление аналогичной помощи вашему коду.

Но, и **это очень важно**, это не абсолютное утверждение. Безусловно, существует множество зла, скрывающегося за неявным преобразованием, которое повредит вашему коду гораздо больше, чем любые потенциальные улучшения читабельности. Ясно, что мы должны научиться избегать таких конструкций, чтобы не отравлять наш код всевозможными ошибками.

Многие разработчики полагают, что если механизм может сделать какую-то полезную вещь *А*, но также может быть злоупотреблен или неправильно использован для совершения какой-то ужасной вещи *Z*, то мы должны вообще отказаться от этого механизма, просто чтобы быть в безопасности.

Мой вам совет: не соглашайтесь на это. Не думайте, что неявное преобразование - это плохо, потому что все, что вы когда-либо видели, это его "плохие стороны". Я думаю, что у него есть "хорошие стороны", и я хочу помочь и вдохновить вас найти и принять их!

### Неявно: строки <-> числа

Ранее в этой главе мы исследовали *явное* приведение типов между строковыми и числовыми значениями. Теперь давайте рассмотрим ту же задачу, но с *неявным* подходом к приведению. Но прежде чем мы это сделаем, мы должны рассмотреть некоторые нюансы операций, которые вызывают неявное приведение.

Оператор `+` занят как для сложения чисел, так и для конкатенации строк. Так как же JS узнает, какой тип операции вы хотите использовать? Рассмотрим:

```js
var a = "42";
var b = "0";

var c = 42;
var d = 0;

a + b; // "420"
c + d; // 42
```

Какое различие в операциях приводит к результату `"420"` или `42`? Есть распространенное заблуждение, что разница в том, являются ли один или оба операнда строкой, поскольку это означает, что `+` будет предполагать конкатенацию строк. Хотя это отчасти правда, это сложнее, чем кажется.

Рассмотрим:

```js
var a = [1,2];
var b = [3,4];

a + b; // "1,23,4"
```

Ни один из этих операндов не является строкой, но очевидно, что оба они были приведены к строкам, а затем вступила в силу конкатенация строк. Так что же на самом деле происходит?

(**Предупреждение:** сейчас будет отрывок из спецификации, можете пропустить следующие два абзаца, если это вас пугает!)

-----

В соответствии с разделом 11.6.1 спецификации ES5 алгоритм `+` (когда операндом является объект) произведет конкатенацию, если любой из операндов уже является строкой или если следующие шаги приводят к строковому представлению. Таким образом, когда `+` получает объект (в т.ч. массив) в любом из операндов, он сначала вызывает абстрактную операцию `ToPrimitive` (раздел 9.1) с этим значением, которая затем вызывает алгоритм `[[DefaultValue]]` (раздел 8.12.8) с подсказкой контекста числа.

Если вы обратите пристальное внимание, вы заметите, что эта операция идентична тому, как абстрактная операция `ToNumber` обрабатывает объекты (см. Раздел "ToNumber" "ранее). Операция `valueOf()` в массиве не сможет произвести простой примитив, поэтому он переходит к представлению `toString()`. Таким образом, эти два массива становятся `"1,2"` и `"3,4"` соответственно. Теперь `+` конкатенирует две строки, как вы и ожидаете: `"1, 23,4"` .

Оставим в стороне эти детали и вернемся к более раннему упрощенному объяснению: если любой из операндов + представляет собой строку (или становится таковой с вышеуказанными шагами!), будет произведена конкатенацией строк. В противном случае это всегда числовое сложение.


**Примечание:** Есть часто цитируемый пример приведения типов - `[] + {}` vs. `{} + []`, поскольку эти два выражения приводят, соответственно, к `"[object Object]"` и `0`. Однако это еще не все, и мы рассмотрим эти подробности в разделе "Блоки" в главе 5.

Что это значит для *неявного* приведения?

Вы можете привести число к строке, просто "сложив" число и `""` пустую строку:


```js
var a = 42;
var b = a + "";

b; // "42"
```

**Подсказка:** Числовое сложение с оператором `+` является коммутативным, это означает, что `2 + 3` - это то же самое, что и `3 + 2`. Конкатенация строк с `+`, очевидно, не является коммутативной, но в конкретном случае с `""` она коммутативна, как `a + ""` и `"" + a` приведут к одинаковому результату.

Чрезвычайно распространено / идиоматично (неявно) приводить число к строке с помощью операции `"+"`. На самом деле, что интересно, даже некоторые из наиболее активных критиков неявного приведения все еще используют этот подход в своем коде вместо одной из его явных альтернатив.

Я думаю, что это отличный пример **полезной формы неявного приведения**, несмотря на то, как часто этот механизм подвергается критике!

Сравнивая это *неявное* приведение `+ ""` с нашим более ранним примером явного приведения `String(a)`, есть еще одна особенность, о которой нужно знать. Из-за того, как работает абстрактная операция `ToPrimitive`, `+ ""` вызывает `valueOf()` для значения `a`, возвращаемое значение которого затем окончательно преобразуется в строку с помощью внутренней абстрактной операции `ToString`. Но `String(a)` просто вызывает `toString()` напрямую.

Оба подхода в конечном итоге приводят к появлению строки, **но** если вы используете объект вместо обычного примитивного числового значения, вы не обязательно получите одно и то же строковое значение!

Рассмотрим:

```js
var a = {
	valueOf: function() { return 42; },
	toString: function() { return 4; }
};

a + "";			// "42"

String( a );	// "4"
```

Как правило, вы не поведетесь на такого рода уловки, если вы не пытаетесь намеренно создать запутанные структуры данных и операции, но вы должны быть осторожны, если вы определяете как свои собственные методы `valueOf()` и `toString()` для некоторого объекта, в таком случае то, как вы приведете значение, может повлиять на результат.

Как насчет обратного направления? Как мы можем *неявно привести* строку к числу?


```
var a = "3.14";
var b = a - 0;

b; // 3.14
```

Оператор `-` определен только для числового вычитания, поэтому `- 0` приводит значение к числу. Хотя `* 1` или `/ 1` встречаются гораздо реже, они приводят к тому же результату, поскольку эти операторы также определены только для числовых операций.

Как насчет объектов с оператором `-`? Похоже на происходящее с `+` выше:


```js
var a = [3];
var b = [1];

a - b; // 2
```

Оба значения массива должны стать числами, но в итоге они сначала приводятся к строкам (используя ожидаемую сериализацию `toString()`), а затем приводятся к числам для выполнения вычитания `-`.

Итак, является ли *неявное* преобразование строковых и числовых значений ужасным злом, о котором вы всегда слышали страшные истории? Я лично так не думаю.

Сравните `b = String(a)` (явно) с `b = a + ""` (неявно). Я думаю, что в разных случаях могут быть полезны оба подхода. `b = a + ""` довольно часто встречается в программах JS, доказывая свою полезность, независимо от того, что вы думаете по поводу достоинств или опасностей *неявного* преобразования в целом.


### Неявно: Boolean --> Число

Я думаю, случай, когда *неявное* преобразование действительно может быть полезней, `-` это упрощение некоторых видов сложной булевой логики в простое сложение чисел. Конечно, это не метод общего назначения, а конкретное решение для конкретных случаев.

Рассмотрим:

```js
function onlyOne(a,b,c) {
	return !!((a && !b && !c) ||
		(!a && b && !c) || (!a && !b && c));
}

var a = true;
var b = false;

onlyOne( a, b, b );	// true
onlyOne( b, a, b );	// true

onlyOne( a, b, a );	// false
```

Эта утилита `onlyOne(..)` должна возвращать `true`, только если один из аргументов является `true` / приводится к `true`. Она использует неявное преобразование к проверкам на истинность и явное преобразование к остальным, включая окончательное возвращаемое значение.

Но что если нам понадобится эта утилита, чтобы обрабатывать четыре, пять или двадцать флагов таким же образом? Довольно сложно представить реализацию кода, который бы обрабатывал все эти перестановки сравнений.

Вот где приведение логических значений к числам (очевидно, `0` или `1`) может сильно помочь:


```js
function onlyOne() {
	var sum = 0;
	for (var i=0; i < arguments.length; i++) {
		// skip falsy values. same as treating
		// them as 0's, but avoids NaN's.
		if (arguments[i]) {
			sum += arguments[i];
		}
	}
	return sum == 1;
}

var a = true;
var b = false;

onlyOne( b, a );				// true
onlyOne( b, a, b, b, b );		// true

onlyOne( b, b );				// false
onlyOne( b, a, b, b, b, a );	// false
```

**Примечание:** Конечно, вместо цикла for в `onlyOne(..)` вы могли бы более кратко использовать утилиту ES5 `Reduce(..)`, но я не хотел затенять концепции.

То, что мы делаем здесь - полагаемся на `1` для `true` / приводимого к `true` и численно складываем их все. `sum += arguments[i]` использует для этого неявное преобразование. Если одно и только одно значение в списке аргументов равно `true`, тогда числовая сумма будет равна `1`, в противном случае сумма не будет равна `1`, и, следовательно, требуемое условие не будет выполнено.

Конечно, мы могли бы сделать это с явным преобразованием:


```js
function onlyOne() {
	var sum = 0;
	for (var i=0; i < arguments.length; i++) {
		sum += Number( !!arguments[i] );
	}
	return sum === 1;
}
```

Сначала мы используем `!!arguments[i]` для приведения значения к `true` или `false`. Это значит, что вы можете передавать не булевы значения, например, `onlyOne("42", 0)`, и все равно будет работать так, как ожидается (в противном случае вы бы получили конкатенацию строк и логика была бы неправильной).

Как только мы убедились, что это логическое значение, мы делаем другое явное приведение с помощью `Number(..)`, чтобы убедиться, что значение равно `0` или `1`.

Лучше ли форма этой утилиты с *явным* преобразованием? Она позволяет избежать ловушки с `NaN`, как объясняется в комментариях в коде. Но, в конечном итоге, это зависит от ваших потребностей. Я лично считаю, что предыдущая версия, опирающаяся на неявное преобразование, более элегантна (если вы не передадите `undefined` или `NaN`), а явная версия излишне многословна.

Но, как и почти все, что мы обсуждаем здесь, это призыв к рассуждению.


**Примечание:** Независимо от неявного или явного подхода, вы можете легко сделать вариации `onlyTwo(..)` или `onlyFive(..)`, просто изменив окончательное сравнение с `1`, `2` или `5` соответственно. Это значительно проще, чем добавить кучу `&&` и `||` выражений. Так что, как правило, преобразование очень полезно в этом случае.

### Неявно: * --> Boolean

Теперь давайте обратим наше внимание на неявное приведение к булевым значениям, поскольку оно является наиболее распространенным, а также наиболее потенциально проблематичным.

Помните, что неявное преобразование вступает в силу, когда вы используете значение таким образом, при котором вызывается преобразование значения. Для числовых и строковых операций довольно легко увидеть, как могут происходить преобразования.

Но какие операции требуют/ неявно выполняют преобразование в булевый тип?

1. Проверяемое выражение в операторе `if (..)`.
2. Проверяемое выражение (второй блок) в заголовке `for (..; ..; ..)`.
3. Проверяемое выражение в циклах `while (..)` и `do.. while (..)`.
4. Проверяемое выражение (первая часть) в `? :` тернарном операторе.
5. Левый операнд (который служит проверяемым выражением - см. ниже!) оператора `||` ("логическое или") и `&&` ("логическое и").

Любое значение, используемое в этих контекстах, которое еще не является логическим, будет *неявно* приведено к логическому с использованием правил абстрактной операции ToBoolean, описанной ранее в этой главе.

Давайте посмотрим некоторые примеры:

```js
var a = 42;
var b = "abc";
var c;
var d = null;

if (a) {
	console.log( "yep" );		// yep
}

while (c) {
	console.log( "nope, never runs" );
}

c = d ? a : b;
c;								// "abc"

if ((a && d) || c) {
	console.log( "yep" );		// yep
}
```

Во всех этих контекстах не булевы значения *неявно* приводятся к их булевым эквивалентам для принятия решений.

### Операторы `||` и `&&`

Вполне вероятно, что вы видели операторы  `||` ("логическое или") и `&&` ("логическое и") в большинстве или во всех других языках, которые вы использовали. Поэтому было бы естественно предположить, что в JavaScript они работают в основном так же, как и в других похожих языках.

Здесь есть очень малоизвестный, но очень важный нюанс.

На самом деле, я бы сказал, что эти операторы не следует даже называть "логическими операторами", так как это название неполно в описании того, что они делают. Я бы дал им более точное (хотя и более неуклюжее) название - *"операторы выбора"* или, если быть точнее, *"операторы выбора операнда"*.

Почему? Потому что они на самом деле не приводят к логическому значению в JavaScript, как делают это в некоторых других языках.

Так к чему они приводят? Они **приводят к значению одного (и только одного) из их двух операндов**. Другими словами, они выбирают одно из двух значений операнда.

Цитируя спецификацию ES5 из раздела 11.11:

> Значение, полученное с помощью операторов `&&` или `||` не обязательно имеет тип Boolean. Полученное значение всегда будет значением одного из двух выражений операнда.

Давайте проиллюстрируем:

```js
var a = 42;
var b = "abc";
var c = null;

a || b;		// 42
a && b;		// "abc"

c || b;		// "abc"
c && b;		// null
```

**Стоп, что!?** Подумайте об этом. В таких языках, таких как C и PHP, эти выражения приводят к `true` или `false`, но в JS (а также Python и Ruby!) получается результат из самих значений.

Оба оператора `||` и `&&` выполняют логическую проверку для первого операнда (`a` или `c`). Если операнд еще не является логическим (как здесь), происходит нормальное приведение `ToBoolean`, чтобы проверка могла быть выполнена.

Для оператора `||`, если проверка верна, возвращается значение первого операнда (`а` или `с`). Если проверка не верна, возвращается значение второго операнда (`b`).

А для оператора `&&`, наоборот, если проверка верна, возвращается значение второго операнда (`b`). Если проверка не верна, возвращается значение первого операнда (`a` или `c`).

Результат `||` или `&&` всегда является базовым значением одного из операндов, а не результатом проверки (возможно, с использованием преобразования типов). В `c && b` - `c = null` и, следовательно, приводится к `false`. Но само выражение `&&` возвращает `null` (значение в `c`), а не `false`, используемое при проверке.

Теперь вы видите, как эти операторы "выбирают операнды"?

Еще один взгляд на эти операторы:

```js
a || b;
// приблизительно равно:
a ? a : b;

a && b;
// приблизительно равно:
a ? b : a;
```

**Примечание:** я говорю, что `a || b` *"приблизительно равно"* `a ? a : b`, потому что результат идентичен, но есть нюанс. В `a ? a : b`, если `a` было бы более сложным выражением (как, например, выражение, которое может иметь побочные эффекты, такие как вызов функции и т. д.), то выражение `a`, возможно, будет проверяться дважды (если первая оценка была верной). Для `a || b`, выражение `a` проверяется только один раз, и это значение используется как для проверки с преобразованием типа, так и для значения результата (при необходимости). Тот же нюанс относится к `a && b` и `a ? б:`.

Чрезвычайно распространенное и полезное использование этого поведения, которое, вероятно, вы уже использовали раньше и до конца не поняли:

```js
function foo(a,b) {
	a = a || "hello";
	b = b || "world";

	console.log( a + " " + b );
}

foo();					// "hello world"
foo( "yeah", "yeah!" );	// "yeah yeah!"
```

Выражение `a = а || "hello"` (иногда называемое JavaScript-версией C# "оператора объединения со значением `null"`) проверяет переменную `a` и, если она не имеет значения (или имеет нежелательное приводимое к ложному значение), предоставляет запасное значение по умолчанию (`"hello"`)

**Однако, будьте осторожны!**

```js
foo( "That's it!", "" ); // "That's it! world" <-- Oops!
```
Это выражение чрезвычайно распространено и весьма полезно, но вы должны использовать его только в тех случаях, когда все ложные значения должны быть пропущены. В противном случае вам нужно быть более явным в своей проверке и, возможно, использовать вместо него тернарный оператор `? :`.

Это выражение присвоения значений по умолчанию настолько распространено (и полезно!), Что даже те, кто публично и яростно осуждают приведение типов JavaScript, часто используют его в своем коде!

Что насчет `&&`?

Есть еще одно выражение, которое несколько реже создается вручную, но которое часто используется в JS минификаторах. Оператор `&&` "выбирает" второй операнд тогда и только тогда, когда первый операнд является true, и такое использование иногда называют "охраняющим оператором" (см. также "Короткое замыкание" в главе 5) - проверка первого выражения  “охраняет” второе:

```js
function foo() {
	console.log( a );
}

var a = 42;

a && foo(); // 42
```

`foo()` вызывается только потому, что проверка верна. Если эта проверка не пройдена, оператор `&&` просто молча остановится - это называется "коротким замыканием" - и никогда не вызовет `foo()`.

Опять же, не так часто пишут такие вещи. Обычно вместо этого делают `if (a){ foo(); }`. Но минификаторы JS выбирают `&& foo()`, потому что так намного короче. Итак, теперь, если вам когда-нибудь понадобится расшифровать такой код, вы будете знать, что он делает и почему.

Хорошо, у `||` и `&&` есть несколько хитрых уловок в рукаве, если вы готовы добавить немного неявного преобразования типов.

**Примечание:** и `a = b || "что-то"`, и `a && b ()` основаны на поведении короткого замыкания, которое мы более подробно рассмотрим в главе 5.

Тот факт, что эти операторы на самом деле не приводят к истинному и ложному, возможно, уже немного вызывает путаницу в вашей голове. Вы, вероятно, задаетесь вопросом, как все это время работали все ваши операторы if и for, если они включали сложные логические выражения, такие как a `&& (b || c)`.

Не волнуйтесь! Небо не падает. С вашим кодом (вероятно) все в порядке. Просто вы, наверно, никогда раньше не осознавали, что **после** проверки составного выражения происходит неявное приведение к логическому значению.

Рассмотрим:

```js
var a = 42;
var b = null;
var c = "foo";

if (a && (b || c)) {
	console.log( "yep" );
}
```

Этот код по-прежнему работает так, как вы всегда думали, за исключением одной тонкой дополнительной детали. Выражение `a && (b || c)` фактически приводит к `"foo"`, а не к `true`. После чего, оператор `if` преобразует `"foo"` к логическому типу, что, конечно, даст `true`.

Видите? Нет причин для паники. Ваш код, вероятно, все еще в безопасности. Но теперь вы знаете больше о том, как он делает то, что делает.

И теперь вы также понимаете, что такой код использует *неявное* преобразование. Если вы все еще находитесь в "лагере избегающих (неявного) приведения типов", вам нужно будет вернуться назад и заменить преобразование во всех этих примерах на *явное*:


```js
if (!!a && (!!b || !!c)) {
	console.log( "yep" );
}
```

Удачи с этим! ... Извините, это шутка.

### Приведение Symbol 

До этого момента между явным и неявным приведением почти не было заметной разницы в результатах - на карту поставлена ​​только читаемость кода.

Но символы из ES6 вводят в систему преобразования хитрость, которую мы должны кратко обсудить. По причинам, которые выходят далеко за рамки того, что мы обсудим в этой книге, явное приведение символа к строке допускается, но неявное приведение не допускается и выдает ошибку.

Рассмотрим:

```js
var s1 = Symbol( "cool" );
String( s1 );					// "Symbol(cool)"

var s2 = Symbol( "not cool" );
s2 + "";						// TypeError
```

Значения символов вообще не могут быть приведены к числу (выдается ошибка в любом случае), но, как ни странно, они могут как явно, так и неявно быть приведены к логическому типу (всегда `true`).

Последовательность всегда легче выучить, и с исключениями никогда не бывает весело иметь дело, но нам просто нужно быть осторожными в отношении новых значений символов из ES6 и того, как мы их приводим.

Хорошая новость: вам, вероятно, крайне редко нужно будет приводить значение символа. То, как они обычно используются (см. главу 3), вероятно, не потребует преобразования в нормальных условиях.

## Строгое vs. нестрогое равенство

Нестрогое равенство - это оператор `==`, а строгое равенство - это оператор `===`. Оба оператора используются для проверки двух значений на "равенство", но "строгое" и "нестрогое" указывают на **очень важное различие** в поведении между ними, особенно в том, как они принимают решение о "равенстве".

Очень распространенное заблуждение об этих двух операторах: "`==` проверяет значения на равенство, а `===` проверяет и значения, и типы на равенство". Хотя это звучит красиво и разумно, но неточно. Бесчисленные уважаемые книги и блоги по JavaScript говорят именно это, но, к сожалению, все они не правы.

Правильное описание: "`==` разрешает преобразование типа при проверке на равенство, а `===` запрещает".

### Производительность равенства

Остановитесь и подумайте о разнице между первым (неточным) объяснением и вторым (точным).

В первом объяснении кажется очевидным, что `===` выполняет больше работы, чем `==`, потому что он также должен проверять тип. Во втором объяснении `==` выполняет больше работы, потому что он должен выполнить преобразование, если типы различаются.

Не попадайтесь в ловушку, многие думают, что это как-то связано с производительностью, будто `==` будет медленнее, чем `===`. Несмотря на то, что измеримо, что преобразование типа действительно занимает немного времени обработки, это всего лишь микросекунды (да, это миллионные доли секунды!).

Если вы сравниваете два значения одинаковых типов, `==` и `===` используют идентичный алгоритм, и поэтому, кроме незначительных различий в реализации движка, они должны выполнять ту же работу.

Если вы сравниваете два значения разных типов, производительность не является важным фактором. Вы должны спросить себя: сравнивая эти два значения, хочу ли я преобразовывать тип или нет?

Если вы этого хотите, используйте `==` нестрогое равенство, а если не хотите, используйте `===` строгое равенство.


**Примечание:** здесь подразумевается, что и `==`, и `===` проверяют типы своих операндов. Разница в том, как они реагируют, если типы не совпадают.

### Абстрактное равенство

Поведение оператора `==` определяется как "Алгоритм абстрактного равенства" в разделе 11.9.3 спецификации ES5. То, что перечислено там, является всесторонним, но простым алгоритмом, который явно указывает каждую возможную комбинацию типов, и как преобразования (при необходимости) должны происходить для каждой комбинации.

**Предупреждение:** Когда говорят о (неявное) преобразовании как о слишком сложном и слишком ущербном, чтобы быть полезным, часто обсуждают именно эти правила "абстрактного равенства". В общем, говорят, что они слишком сложны и не слишком понятны для разработчиков, чтобы их можно было изучить и использовать на практике, и что они более склонны вызывать ошибки в программах JS, чем обеспечивать лучшую читаемость кода. Я считаю, что это ошибочная предпосылка - вы, читатели, являетесь компетентными разработчиками, которые пишут (читают и понимают!) алгоритмы (код) весь день. Итак, ниже следует простое изложение "абстрактного равенства" в простых терминах. Но я умоляю вас также прочитать раздел спецификации ES5 11.9.3. Я думаю, вы удивитесь, насколько это разумно.

По сути, первое предложение (11.9.3.1) гласит: если сравниваемые два значения относятся к одному и тому же типу, они просто и естественно сравниваются с помощью идентификатора, как и следовало ожидать. Например, `42` равно только `42`, а `"abc"` равно только `"abc"`.

Некоторые незначительные исключения из обычных ожиданий, о которых следует знать:


*  `NaN` никогда не бывает равным самому себе (см. главу 2)
* `+0` и `-0` равны друг другу (см. главу 2)

Последнее положение в пункте 11.9.3.1 о `==` нестрогом сравнении с объектами (включая функции и массивы). Два таких значения равны, только если они оба являются ссылками на одно и то же значение. Никакого преобразования здесь не происходит.

**Примечание:** `===` строгое сравнение определяется идентично 11.9.3.1, включая положение о двух значениях объекта. Это очень мало известный факт, что и `==`, и `===` ведут себя одинаково в случае сравнения двух объектов!

Остальная часть алгоритма в 11.9.3 указывает, что если вы используете `==` нестрогое равенство для сравнения двух значений разных типов, одно или оба значения должны быть неявно приведены. Это приведение происходит так, что оба значения в конечном итоге оказываются одного и того же типа, которые затем можно напрямую проверить на равенство, используя простое значение Identity.

**Примечание:** Операция `!=` нестрогое неравенство определяется именно так, как вы и ожидали, поскольку это буквально выполнение операции сравнения `==`, выполняемое полностью, а затем отрицание результата. То же самое относится и к операции строгого неравенства `!==`.

#### Сравнение: строки и числа

Чтобы проиллюстрировать приведение с помощью `==`, давайте сначала вернем примеры строк и чисел из этой главы:

```js
var a = 42;
var b = "42";

a === b;	// false
a == b;		// true
```

Как и следовало ожидать, `a === b` терпит неудачу, потому что никакое преобразование не допускается, значения на самом деле `42` и `“42”` различны.

Однако во втором сравнении `a == b` используется нестрогое равенство, что означает, что если типы оказываются разными, алгоритм сравнения будет применять неявное приведение к одному или обоим значениям.

Но что именно здесь происходит? Значение `a` - `42` становится строкой, или значение `b` - `"42"` становится числом?

В спецификации ES5 пункты 11.9.3.4-5 гласят:

> 4. Если `Type(x)` равен `Number`, а `Type(y)` равен `String`,
>    вернуть результат сравнения `x == ToNumber(y).`
> 5. Если `Type(x)` равен `String`, а `Type(y)` равен `Number`,
>    вернуть результат сравнения `ToNumber(x) == y`.

**Предупреждение:** спецификация использует `Number` и `String` в качестве формальных имен для типов, в то время как эта книга предпочитает число и строку (с маленькой буквы) для примитивных типов. Не допускайте, чтобы заглавная буква Number в спецификации сбивала вас, не путайте с функцией `Number()`. Для наших целей использование заглавных букв имени типа не имеет значения.

Понятно, что в спецификации говорится, что значение `"42"` приводится к числу для сравнения. Как это работает уже было рассмотрено ранее, в частности, с помощью абстрактной операции `ToNumber`. В этом случае совершенно очевидно, что полученные два значения `42` равны.


#### Сравнение: чего угодно с `boolean`

Одна из самых больших проблем с неявным преобразование `==` нестрогого равенства возникает, когда вы пытаетесь сравнить значение непосредственно с `true` или `false`.

Рассмотрим:

```js
var a = "42";
var b = true;

a == b;	// false
```

Подождите, что здесь произошло? Мы знаем, что `"42"` является истинным значением (см. Ранее в этой главе). Так почему же оно не равно `== true`?

Причина одновременно проста и хитра. Здесь легко ошибиться, многие разработчики JS никогда не уделяют достаточно внимания, тому чтоб полностью понять это.

Давайте снова процитируем спецификацию, пункты 11.9.3.6-7:

> 6. Если `Type(x)` - `Boolean`, вернуть результат сравнения `ToNumber(x) == y`.
> 7. Если `Type(y)` - `Boolean`, вернуть результат сравнения `x == ToNumber(y)`.

Давайте разберемся с этим. Во-первых:

```js
var x = true;
var y = "42";

x == y; // false
```

`Type(x)` действительно является логическим, поэтому он выполняет `ToNumber(x)`, который приводит  `true` к `1`. Теперь проверяется `1 == "42"`. Типы по-прежнему различны, поэтому (по сути, рекурсивно) мы пересматриваем алгоритм, который, как и выше, приведет к `"42"` к `42`, и `1 == 42` явно ложно.

Поменяем их местами, и все равно получим тот же результат:

```js
var x = "42";
var y = false;

x == y; // false
```

На этот раз `Type(y)` логический, поэтому `ToNumber(y)` возвращает `0`. `"42" == 0` рекурсивно становится `42 == 0`, что, конечно, ложно.

Другими словами, **значение `"42"` не равно ни `== true`, ни `== false`**. Сначала это утверждение может показаться сумасшедшим. Какое значение может быть ни `true`, ни `false`?

Но в этом и проблема! Вы задаете неправильный вопрос. Это не ваша вина, правда. Ваш мозг обманывает вас.

`"42"` действительно приводится к `true`, но `"42" == true` **не выполняет булевых проверок/ преобразований**, независимо от того, что говорит ваш мозг. `"42"` не приводится к булевому значению (`true`), но вместо этого `"true"` приводится к `1`, а затем `"42"` приводится к `42`.

Нравится нам это или нет, но `ToBoolean` здесь даже не участвует, поэтому истинность или ложность `"42"` не имеет отношения к операции `==!`

Важно понять, как алгоритм сравнения `==` ведет себя со всеми различными комбинациями типов. Что касается логического значения по обе стороны от `==`, то оно всегда сначала приводится к числу.

Если вам это кажется странным, вы не одиноки. Я лично рекомендовал бы никогда, ни при каких обстоятельствах, не использовать `== true` или `== false`. Никогда.

Но помните, я говорю только здесь о `==`.` === true` и `=== false` не допускают преобразование, поэтому они защищены от этого скрытого приведения ToNumber.

Рассмотрим:

```js
var a = "42";

// плохо (не сработает!):
if (a == true) {
	// ..
}

// тоже плохо (не сработает!):
if (a === true) {
	// ..
}

// неплохо (работает неявно):
if (a) {
	// ..
}

// еще лучше (работает явно):
if (!!a) {
	// ..
}

// отлично (работает явно):
if (Boolean( a )) {
	// ..
}
```

Если вы избегаете когда-либо использовать `== true` или `== false` (иначе говоря, нестрогое равенство с булевыми значениями) в своем коде, вам никогда не придется беспокоиться об этой ментальной путанице правдивости / ложности.

#### Сравнение: `null` и `undefined`

Другой пример неявного преобразования можно увидеть при `==` нестрогом равенстве между значениями `null` и `undefined`. Еще раз процитирую спецификацию ES5, пункты 11.9.3.2-3:

> 2. Если `x` равно `null`, а `y` `undefined`, вернуть `true`.
> 3. Если `x` `undefined`, а `y` равно `null`, вернуть `true`.

`null` и `undefined`, при `==` нестрогом равенством, приравниваются друг к другу (и приводят тип, очевидно), и ни к какому другому значению во всем языке (кроме самих себя, естественно).

Это означает, что значения `null` и `undefined` могут рассматриваться как неразличимые для целей сравнения, если вы используете оператор `==` нестрогого равенства, что разрешает их взаимное неявное приведение друг к другу.


```js
var a = null;
var b;

a == b;		// true
a == null;	// true
b == null;	// true

a == false;	// false
b == false;	// false
a == "";	// false
b == "";	// false
a == 0;		// false
b == 0;		// false
```

Приведение между `null` и `undefined` - безопасное и предсказуемое, и никакие другие значения не могут дать ложных срабатываний в такой проверке. Я рекомендую использовать это приведение, чтобы значения `null` и `undefined` были неразличимы и, следовательно, обрабатывались как одно и то же значение.

Например:

```js
var a = doSomething();

if (a == null) {
	// ..
}
```

Проверка `a == null` пройдет, только если `doSomething()` вернет `null` или `undefined`, и потерпит неудачу с любым другим значением, даже с другими приводимыми к ложным значениями, такими как `0`, `false` и `""`.

*Явная* форма проверки, которая запрещает любое такое преобразование, является (я думаю) излишне более уродливой (и, возможно, чуть менее производительной!):


```js
var a = doSomething();

if (a === undefined || a === null) {
	// ..
}
```

На мой взгляд, форма `== null` - это еще один пример, где неявное приведение улучшает читабельность кода, но делает это надежным безопасным способом.

#### Сравнение: объекты и не-объекты

Если объект / функция / массив сравнивается с простым скалярным примитивом (строка, число или логическое значение), спецификация ES5 в пунктах 11.9.3.8-9 говорит следующее:

> 8. Если `Type(x)` равен `String` или `Number`, а `Type(y)` равен `Object`, возвращать результат сравнения `x == ToPrimitive(y)`.
> 9. Если `Type(x)` равен `Object`, а `Type(y)` - `String` или `Number`, вернуть результат сравнения `ToPrimitive(x) == y`.

**Примечание:** Вы можете заметить, что в этих пунктах упоминаются только `String` и `Number`, но не `Boolean`. Это связано с тем, что, как указывалось ранее, пункты 11.9.3.6-7 заботятся о том, чтобы сначала приводить любой булевый операнд к `Number`.

Рассмотрим:

```js
var a = 42;
var b = [ 42 ];

a == b;	// true
```

Для значения `[42]` вызывается его стандартная операция `ToPrimitive` (см. Раздел "Операции с абстрактным значением" ранее), что приводит к значению `"42"`. Здесь это просто `42 == "42"`, что, как мы уже рассмотрели, становится `42 == 42`, так что `a` и `b` после приведения типов оказываются равными.


**Подсказка:** Все особенности абстрактной операции `ToPrimitive`, которые мы обсуждали ранее в этой главе (`toString()`, `valueOf()`), применяются здесь, как и следовало ожидать. Это может быть очень полезно, если у вас есть сложная структура данных, для которой вы хотите определить собственный метод `valueOf()`, чтобы предоставить простое значение для проверки на равенство.

В главе 3 мы рассмотрели "распаковку", когда оболочка объекта вокруг примитивного значения (например new `String("abc")`) разворачивается, и возвращается базовое примитивное значение (`"abc"`). Это поведение связано с приведением `ToPrimitive` в алгоритме `==`:


```js
var a = "abc";
var b = Object( a );	// то же, что`new String( a )`

a === b;				// false
a == b;					// true
```

`a == b` верно, потому что `b` приводится (или "распаковывается") с помощью `ToPrimitive` к своему базовому простому скалярному примитиву `"abc"`, который совпадает со значением в `a`.

Однако есть некоторые значения, которые не соответствуют действительности из-за других переопределяющих правил в алгоритме `==`. Рассмотрим:


```js
var a = null;
var b = Object( a );	// то же, что `Object()`
a == b;					// false

var c = undefined;
var d = Object( c );	// то же, что `Object()`
c == d;					// false

var e = NaN;
var f = Object( e );	// то же, что `new Number( e )`
e == f;					// false
```

Значения `null` и `undefined` не могут быть распакованы - у них нет эквивалентного объекта-обертки  - поэтому `Object(null)` похож на `Object()` в том смысле, что оба производят обычный объект.

`NaN` может быть упакован в его эквивалентный объект-обертку `Number`, но когда `==` вызывает распаковку, сравнение `NaN == NaN` завершается неудачей, потому что `NaN` никогда не равен самому себе (см. главу 2).

### Опасные случаи

Теперь, когда мы тщательно изучили, как работает неявное преобразование `==` нестрогого равенства (как разумным, так и неожиданным образом), давайте попробуем выявить наихудшие, самые безумные случаи, чтобы мы могли увидеть, чего нам стоит избегать, чтобы не вызывать баги с преобразованием типов.

Сначала давайте рассмотрим, как модификация встроенных прототипов может привести к сумасшедшим результатам:

#### Число с любым другим значением будет …

```js
Number.prototype.valueOf = function() {
	return 3;
};

new Number( 2 ) == 3;	// true
```

**Предупреждение:** `2 == 3` не попало бы в эту ловушку, потому что ни `2`, ни `3` не вызвали бы встроенный метод `Number.prototype.valueOf()`, поскольку оба они уже являются значениями примитивных чисел и могут сравниваться напрямую. Однако new `Number(2)` должен пройти приведение `ToPrimitive` и, таким образом, вызвать `valueOf()`.

Страшно, да? Конечно. Никто никогда не должен этого делать. Тот факт, что вы можете сделать это, иногда используется как критика преобразования `==`. Но это неверно направленное разочарование. JavaScript не плох, потому что вы можете делать такие вещи, **а разработчики плохи, если они делают такие вещи**. Не впадайте в заблуждение "мой язык программирования должен защищать меня от самого себя".

Далее, давайте рассмотрим еще один хитрый пример, который переносит зло из предыдущего примера на другой уровень:

```js
if (a == 2 && a == 3) {
	// ..
}
```

Вы можете подумать, что это невозможно, потому что a никогда не может быть одновременно равным `2` и `3` одновременно. Но "одновременно" - это неточно, поскольку первое выражение `a == 2` происходит строго перед `a == 3`.

Итак, что если мы заставим `a.valueOf()` иметь побочные эффекты каждый раз, когда он вызывается, так что в первый раз он возвращает `2`, а во второй раз, когда он вызывается, возвращает `3`? Довольно легко:

```js
var i = 2;

Number.prototype.valueOf = function() {
	return i++;
};

var a = new Number( 42 );

if (a == 2 && a == 3) {
	console.log( "Yep, this happened." );
}
```

Опять же, это злые трюки. Не делайте их. Но также не используйте их как жалобы на приведение типов. Потенциальные злоупотребления механизмом не являются достаточным доказательством для осуждения этого механизма. Просто избегайте этих сумасшедших уловок и придерживайтесь только правильного и уместного использования преобразования.

#### “Ложные” сравнения

Наиболее распространенная жалоба на неявное преобразование в сравнениях с помощью `==` исходит из того, как приводимые к `false` значения ведут себя странно при сравнении друг с другом.

Чтобы проиллюстрировать это, давайте посмотрим на список опасных случаев сравнения ложных значений, чтобы увидеть, какие из них являются разумными, а какие - проблемными:

```js
"0" == null;			// false
"0" == undefined;		// false
"0" == false;			// true -- ОЙ!
"0" == NaN;				// false
"0" == 0;				// true
"0" == "";				// false

false == null;			// false
false == undefined;		// false
false == NaN;			// false
false == 0;				// true -- ОЙ!
false == "";			// true -- ОЙ!
false == [];			// true -- ОЙ!
false == {};			// false

"" == null;				// false
"" == undefined;		// false
"" == NaN;				// false
"" == 0;				// true -- ОЙ!
"" == [];				// true -- ОЙ!
"" == {};				// false

0 == null;				// false
0 == undefined;			// false
0 == NaN;				// false
0 == [];				// true -- ОЙ!
0 == {};				// false
```

В этом списке из 24 сравнений 17 из них вполне разумны и предсказуемы. Например, мы знаем, что `""` и `NaN` вовсе не являются равными значениями, и на самом деле они не преобразуются при нестрогом сравнении, в то время как `"0"` и `0` достаточно разумно равны и приводятся к равным значениям.

Тем не менее, семь сравнений помечены *"ОЙ!"* потому что не правильно возвращая true, они гораздо вероятней приведут к ошибкам, которые могут сбить вас с толку. `""` и `"0"` определенно являются разными значениями, и редко вы хотите рассматривать их как равные, поэтому их взаимное преобразование вызывает затруднения. Обратите внимание, что здесь нет ошибочных результатов `false`.


#### Сумасшедшие примеры

Не будем останавливаться на достигнутом. Мы можем продолжать искать еще более неприятные приведения:

```js
[] == ![];		// true
```

Оооо, это кажется на более высоком уровне сумасшествия, верно!? Ваш мозг, вероятно, обманет вас тем, что вы сравниваете `true` с `false`, поэтому результат `true` удивительный, поскольку мы знаем, что значение никогда не может быть правдивым и ложным одновременно!

Но это не то, что на самом деле происходит. Давайте разберемся. Что мы знаем об унарном операторе `!`? Он явно приводит к логическому значению, используя правила `ToBoolean` (а также меняет значение на противоположное). Поэтому, прежде чем `[] ==! []` будет обработан, он фактически уже переведен в `[] == false`. Мы уже видели эту форму в нашем списке выше (`false == []`), поэтому ее неожиданный результат не новость для нас.

Как насчет других странных случаев?

```js
2 == [2];		// true
"" == [null];	// true
```

Как мы говорили ранее в нашем обсуждении `ToNumber`, значения `[2]` и `[null]` с правой стороны будут проходить через приведение `ToPrimitive`, поэтому их будет легче сравнивать с простыми примитивами (`2` и `""` соответственно) слева.Так как `valueOf()` для значений массива просто возвращает сам массив, приведение сводится к строковому массиву.

`[2]` станет `"2"`, а дальше с помощью ToNumber будет приведено в `2` для соответствия правому значению. `[null]` просто становится `""`.

Итак, `2 == 2` и `"" == ""` вполне понятно.

Если ваш инстинкт все еще не рад этим результатам, ваше разочарование на самом деле не связано с приведением типов, как вы, вероятно, думаете. На самом деле это жалоба на поведение операции по умолчанию `ToPrimitive` для значений массива, приводящее к строковому значению. Скорее всего, вы просто хотели бы, чтобы `[2].toString()` не возвращал `"2"`, или чтобы `[null.toString()` не возвращал `""`.

Но каком именно результат должны возвращать эти преобразования к строке? Я не могу думать о каком-либо другом подходящем приведении `[2]` к строке, кроме `"2"`, разве что, возможно, `"[2]"` - но это может быть очень странно в других контекстах!

Вы могли бы справедливо обосновать, что поскольку `String(null)` становится `"null"`, то `String([null])` также должен становиться `"null"`. Это разумное утверждение. Так вот в чем дело.

Само по себе неявное преобразование не является злом. Даже явное приведение `[null]` к строке приводит к `""`. Противоречие заключается в том, разумно ли вообще, чтобы значения массивов приводились в соответствие с их содержимым, и как именно это происходит. Итак, направьте ваше разочарование на правила для `String([..])`, потому что именно отсюда и происходит сумасшествие. Может быть, вообще не должно быть приведения массивов? Но у этого было бы много других недостатков в других частях языка.

Еще один цитируемый пример:

```js
0 == "\n";		// true
```
Как мы уже обсуждали ранее с пустым `""`, `"\ n"` (или `"  "` или любая другая комбинация пробелов) приводятся через `ToNumber`, и в результате получается `0`. К какому другому числовому значению вы ожидаете привести пробел? Вас беспокоит, что явное приведение к числу `Number("  ")` дает `0`?

На самом деле единственное другое разумное числовое значение, к которому могут привести пустые строки или строки из пробелов, - это `NaN`. Но будет ли это лучше? Сравнение `"" == NaN`, конечно, потерпит неудачу, но не известно, действительно ли мы исправили основные проблемы.

Вероятность сбоя реальной JS-программы из-за того, что `0 == "\ n"` очень мала, и таких случаев легко избежать.

Преобразования типов **всегда** имеют опасные места, в любом языке - это нормально для них. Проблемы здесь касаются повторного угадывания определенного набора опасных случаев (и, возможно, это правильно!?), но это не является существенным аргументом против общего механизма приведения.

Итог: почти любое сумасшедшее приведение между нормальными значениями, с которыми вы, вероятно, столкнетесь (кроме намеренно хитрых хаков `valueOf()` или `toString()`), будет сводиться к короткому списку из семи пунктов представленных выше.

В противопоставление этим 24 вероятным подозреваемым в проблемах с приведением типов, рассмотрим еще один список:

```js
42 == "43";							// false
"foo" == 42;						// false
"true" == true;						// false

42 == "42";							// true
"foo" == [ "foo" ];					// true
```

В этих верных, нормальных случаях (а в этот список мы можем добавить бесконечное количество сравнений) результаты приведения абсолютно безопасны, разумны и объяснимы.

#### Проверка здравомыслия

Хорошо, мы определенно нашли некоторые безумства, когда глубоко изучили скрытое приведение. Неудивительно, что большинство разработчиков утверждают, что преобразование типов является злом и его следует избегать.

Но давайте сделаем шаг назад и проведем проверку здравомыслия.

При сравнении величин у нас есть список из семи проблемных случаев приведения, но у нас есть еще один список (по крайней мере из 17 значений, но на самом деле он бесконечный) приведений, которые полностью разумны и объяснимы.

Если вы ищете в учебнике пример "отказа от полезного во избежание возможного зла", то вот оно: избегание всего приведения типов (бесконечно большого списка безопасного и полезного поведения) из-за буквально всего семи ошибок.

Более разумной реакцией было бы спросить: "Как же я могу использовать бесчисленные *хорошие качества* преобразования типов, но избежать *нескольких проблем*?"

Давайте снова посмотрим на плохой список:


```js
"0" == false;			// true -- ОЙ!
false == 0;				// true -- ОЙ!
false == "";			// true -- ОЙ!
false == [];			// true -- ОЙ!
"" == 0;				// true -- ОЙ!
"" == [];				// true -- ОЙ!
0 == [];				// true -- ОЙ!
```

Четыре из семи пунктов этого списка включают сравнение `== false`, о котором мы говорили ранее и которое **всегда** следует избегать. Это правило довольно просто запомнить.

Теперь список из трех пунктов.


```js
"" == 0;				// true -- ОЙ!
"" == [];				// true -- ОЙ!
0 == [];				// true -- ОЙ!
```

Являются ли эти преобразования разумными и распространенными в обычных JavaScript-программах? При каких условиях они действительно произойдут?

Я не думаю, что вы буквально использовали бы `== []` в логической проверке в вашей программе, по крайней мере, если бы вы знали, что делаете. Вы, вероятно, вместо этого будете делать `== ""` или `== 0`, например:

```js
function doSomething(a) {
	if (a == "") {
		// ..
	}
}
```

У вас будет проблема, если вы случайно вызовете `doSomething(0)` или `doSomething([])`. Другой сценарий:

```js
function doSomething(a,b) {
	if (a == b) {
		// ..
	}
}
```

Опять же, это может сломаться, если вы сделаете что-то вроде `doSomething("", 0)` или `doSomething([], "")`.

Так что, хотя могут существовать ситуации, когда эти приведения будут вызывать проблемы, и вам стоит быть осторожными с ними, но они, вероятно, не слишком распространены во всей вашей кодовой базе.


#### Безопасное использование неявного приведенияss

Самый важный совет, который я могу вам дать: изучите вашу программу и подумайте, какие значения могут отображаться с обеих сторон сравнения `==`. Чтобы эффективно избежать проблем с такими сравнениями, вот несколько эвристических правил:

1. Если любая из сторон сравнения может иметь значения true или false, никогда, НИКОГДА не используйте `==`.
2. Если любая из сторон сравнения может иметь значения `[]`, `""` или `0`, серьезно подумайте о том, чтобы не использовать `==`.

В этих сценариях почти наверняка лучше использовать `===` вместо `==`, чтобы избежать нежелательного приведения. Следуйте этим двум простым правилам, и в значительной степени вы избежите всех проблем с преобразованиями, которые могут причинить вам вред.

**Быть более явным / многословным в этих случаях избавит вас от многих головных болей.**

Вопрос `==` или `===` правильнее всего формулировать так: разрешить ли вам преобразование типов при сравнении или нет?

Во многих случаях такое преобразование может быть полезным, позволяя вам более кратко выразить некоторую логику сравнения (например, с помощью `null` и `undefined`).

В общей схеме есть относительно немного случаев, когда неявное приведение действительно опасно. Но в этих местах, ради безопасности, обязательно используйте `===`.

**Подсказка:** еще одно место, где преобразование гарантированно безопасно, это оператор `typeof`. `typeof` всегда возвращает одну из семи строк (см. главу 1), и ни одна из них не является пустой `""` строкой. Таким образом, не существует случая, когда проверка типа некоторого значения будет нарушать неявное приведение. `typeof x == "function"` на 100% безопасно и надежно так же, как `typeof x === "function"`. Буквально в спецификации говорится, что алгоритм будет идентичен в этой ситуации. Так что не просто слепо используйте `===` везде, просто потому, что ваши инструменты работы с кодом так говорят, или (что хуже всего), потому что в какой-то книге вам сказали не думать об этом. Вы владеете качеством вашего кода.

Является ли неявное преобразование злым и опасным? В некоторых случаях да, но в подавляющем большинстве случаев нет.

Будьте ответственным и зрелым разработчиком. Узнайте, как эффективно и безопасно использовать силу преобразования (как явного, так и неявного). И научите окружающих делать то же самое.

Вот удобная таблица, сделанная Алексом Дореем (@dorey на GitHub) для визуализации различных сравнений:

<img src="fig1.png" width="600">

Источник: https://github.com/dorey/JavaScript-Equality-Table

## Абстрактное относительное сравнение

Хотя этой части *неявного* приведения часто уделяется гораздо меньше внимания, тем не менее важно подумать о том, что происходит при сравнении `а < b` (аналогично тому, как мы только что подробно изучили `a == b`).

Алгоритм "Абстрактного относительного сравнения" в разделе ES.8 11.8.5 по существу делится на две части: что делать, если сравнение применяется к двум строковым значениям (вторая часть) и если оно применяется к чему-то еще (первая часть).

**Примечание:** алгоритм определен только для `a < b`. Т.е., `a > b` обрабатывается как `b < a`.

Алгоритм сначала вызывает приведение `ToPrimitive` к обоим значениям, и, если результат любого вызова не является строкой, то оба значения приводятся к числам с использованием правил операции `ToNumber` и сравниваются численно.

Например:

```js
var a = [ 42 ];
var b = [ "43" ];

a < b;	// true
b < a;	// false
```

**Примечание:** Здесь применяются аналогичные предостережения относительно `-0` и `NaN`, как и в алгоритме `==`, рассмотренном ранее.

Однако, если оба значения являются строками, для `<` сравнения, выполняется простое лексикографическое (натуральное алфавитное) сравнение символов:

```js
var a = [ "42" ];
var b = [ "043" ];

a < b;	// false
```

`a` и `b` *не* приводятся к числам, потому что оба они становятся строками после вызова `ToPrimitive` к двум массивам. Таким образом, `"42"` сравнивается посимвольно с `"043"`, начиная с первых символов `"4"` и `"0"` соответственно. Так как `"0"` лексикографически меньше, чем `"4"`, сравнение возвращает `false`.

Точно такое же поведение и ход мысли относится к:

```js
var a = [ 4, 2 ];
var b = [ 0, 4, 3 ];

a < b;	// false
```

Здесь `a` становится `"4,2"`, а `b` становится `"0,4,3"`, и они лексикографически сравниваются идентично предыдущему примеру.

Как насчет:

```js
var a = { b: 42 };
var b = { b: 43 };

a < b;	// ??
```

`a < b` тоже выдаст `false`, потому что a становится `[object Object]` и `b` становится `[object Object]`, и поэтому ясно, что `a` лексикографически не меньше, чем `b`.

Но странно:

```js
var a = { b: 42 };
var b = { b: 43 };

a < b;	// false
a == b;	// false
a > b;	// false

a <= b;	// true
a >= b;	// true
```

Почему `a == b` не `true`? Это одно и то же строковое значение (`"[object Object]"`), поэтому кажется, что они должны быть равны, верно? Нет. Вспомните предыдущее обсуждение о том, как `==` работает со ссылками на объекты.

Но тогда как `a <= b` и `a >= b `приводят к `true`, если и `a < b`, и `a == b`, и `a > b` все `false`?

Как говорит спецификация, при `a <= b`, фактически сначала проверяется `b < a`, а затем отрицается этот результат. Поскольку `b < a` также ложно, результат `a <= b` верно.

Это, вероятно, ужасно противоречит тому, как вы, до сих пор, могли объяснить, что делает `<=`, что, скорее всего, было буквально: "меньше или равно". Если быть точнее JS считает `<=` **"не больше чем"** (`!(a > b`), что JS рассматривает как `!(b < a)`). Более того, `a >= b` объясняется тем, что сначала это рассматривается как `b <= a`, а затем применяются те же рассуждения.

К сожалению, не существует "строгого относительного сравнения", как для равенства. Другими словами, нет способа предотвратить неявное преобразование при относительных сравнениях, таких как `a < b`, за исключением того, что перед выполнением сравнения явно следует убедиться, что `a` и `b` имеют один и тот же тип.

Используйте те же рассуждения, что и в предыдущей теме `==` vs. `===` как проверку здравомыслия. Если преобразование полезно и достаточно безопасно, как в сравнении `42 < 43`, используйте его. С другой стороны, если вам нужно быть уверенным в относительном сравнении, сначала явно приведите значения, прежде чем использовать `<` (или его аналоги).

```js
var a = [ 42 ];
var b = "043";

a < b;						// false -- сравнение строк!
Number( a ) < Number( b );	// true -- сравнение чисел!
```

## Обзор

В этой главе мы обратили внимание на то, как происходит **преобразование типов** JavaScript, которое можно охарактеризовать как явное или неявное.

Преобразование имеет плохую репутацию, но, на самом деле, оно довольно полезно во многих случаях. Важная задача для ответственного разработчика JS - найти время изучить все входы и выходы преобразования, чтобы решить, что поможет улучшить их код, а чего они действительно должны избегать.

Явное преобразование - это код, который, очевидно, предназначен для преобразования значения из одного типа в другой. Его преимущество заключается в улучшении читаемости и удобства сопровождения кода за счет уменьшения путаницы.

Неявное преобразование - это преобразование, которое "скрыто" как побочный эффект какой-либо другой операции, когда не так очевидно, что произойдет преобразование типа. Хотя, может показаться, что неявное преобразование является противоположностью явного и, следовательно, является плохим (и действительно, многие так думают!), фактически неявное преобразование также связано с улучшением читабельности кода.

Преобразование должно использоваться ответственно и осознанно, особенно это касается неявного. Знайте, почему вы пишете код, который вы пишете, и как он работает. Стремитесь писать код, в котором другие смогут легко разобраться и его понять.
